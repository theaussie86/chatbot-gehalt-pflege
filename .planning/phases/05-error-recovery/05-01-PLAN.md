---
phase: 05-error-recovery
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/api/app/actions/documents.ts
  - supabase/functions/process-embeddings/index.ts
  - apps/api/components/DocumentManager.tsx
autonomous: true

must_haves:
  truths:
    - "Admin can click Reprocess on an error document and it transitions pending -> processing -> embedded"
    - "Admin can click Reprocess on an embedded document to regenerate embeddings"
    - "Previous error attempts are preserved and visible in error history"
    - "Document chunks are deleted before reprocessing starts"
  artifacts:
    - path: "apps/api/app/actions/documents.ts"
      provides: "Complete reprocessDocumentAction with chunk cleanup and error history"
      exports: ["reprocessDocumentAction"]
    - path: "supabase/functions/process-embeddings/index.ts"
      provides: "Error handling that appends to error history array"
    - path: "apps/api/components/DocumentManager.tsx"
      provides: "Error history display showing all retry attempts"
  key_links:
    - from: "apps/api/components/DocumentManager.tsx"
      to: "apps/api/app/actions/documents.ts"
      via: "reprocessDocumentAction import and call"
      pattern: "reprocessDocumentAction\\(documentId\\)"
    - from: "apps/api/app/actions/documents.ts"
      to: "document_chunks table"
      via: "Supabase delete before status reset"
      pattern: "supabase.*delete.*document_chunks"
    - from: "supabase/functions/process-embeddings/index.ts"
      to: "error_details array format"
      via: "Append error to existing array"
      pattern: "error_history.*push|concat"
---

<objective>
Implement complete error recovery workflow: Admin can reprocess failed or embedded documents, previous errors are preserved in history, and chunks are properly cleaned up before reprocessing.

Purpose: Complete ERR-01 requirement - admins can recover from processing failures without re-uploading documents.

Output: Working reprocess flow with error history visibility.
</objective>

<execution_context>
@/Users/cweissteiner/.claude/get-shit-done/workflows/execute-plan.md
@/Users/cweissteiner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-error-recovery/05-CONTEXT.md

Key existing code locations:
- Reprocess button UI: apps/api/components/DocumentManager.tsx (lines 951-964)
- Current reprocessDocumentAction: apps/api/app/actions/documents.ts (lines 164-188)
- Edge function error handling: supabase/functions/process-embeddings/index.ts (lines 340-366)
- Error details panel: apps/api/components/DocumentManager.tsx (lines 242-268)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance reprocessDocumentAction with cleanup and error history</name>
  <files>apps/api/app/actions/documents.ts</files>
  <action>
Update `reprocessDocumentAction` to:

1. **Fetch current document** to get existing error_details:
   ```typescript
   const { data: doc } = await supabase
     .from("documents")
     .select("error_details")
     .eq("id", documentId)
     .single();
   ```

2. **Build error history array**:
   - If `doc.error_details` is an array, use it as-is
   - If `doc.error_details` is an object with `message` field, convert to array: `[{ attempt: 1, ...doc.error_details }]`
   - If null/undefined, start with empty array
   - Store in `error_history` variable for later use

3. **Delete existing chunks** before resetting status:
   ```typescript
   await supabase
     .from("document_chunks")
     .delete()
     .eq("document_id", documentId);
   ```

4. **Update document** with reset state:
   ```typescript
   await supabase
     .from("documents")
     .update({
       status: 'pending',
       chunk_count: null,
       processing_stage: null,
       error_details: error_history.length > 0 ? error_history : null
     })
     .eq("id", documentId);
   ```

Note: Keep error_history in error_details field to preserve previous failures. The edge function will append new errors to this array.
  </action>
  <verify>
Run TypeScript check: `cd apps/api && npx tsc --noEmit`
Verify function signature unchanged (no breaking changes to existing callers).
  </verify>
  <done>
reprocessDocumentAction deletes chunks, resets processing state, and preserves error history in array format.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update edge function to append errors to history array</name>
  <files>supabase/functions/process-embeddings/index.ts</files>
  <action>
Modify the error handling block (catch block around line 340-366) to:

1. **Fetch current error_details** before updating:
   ```typescript
   const { data: currentDoc } = await supabase
     .from("documents")
     .select("error_details")
     .eq("id", documentId)
     .single();
   ```

2. **Build error history array**:
   ```typescript
   let errorHistory: any[] = [];
   if (Array.isArray(currentDoc?.error_details)) {
     errorHistory = currentDoc.error_details;
   } else if (currentDoc?.error_details && typeof currentDoc.error_details === 'object') {
     // Convert legacy single error to array format
     errorHistory = [{ attempt: 1, ...currentDoc.error_details }];
   }

   // Append new error
   const newError = {
     attempt: errorHistory.length + 1,
     code: "PROCESSING_ERROR",
     message: error instanceof Error ? error.message : String(error),
     timestamp: new Date().toISOString(),
     stage: currentStage
   };
   errorHistory.push(newError);
   ```

3. **Update document** with new error_details array:
   ```typescript
   await supabase
     .from("documents")
     .update({
       status: "error",
       error_details: errorHistory
     })
     .eq("id", documentId);
   ```

This ensures multiple reprocess attempts build up a visible history of failures for debugging.
  </action>
  <verify>
Deploy edge function to Supabase: `cd /Users/cweissteiner/NextJS/chatbot-gehalt-pflege && supabase functions deploy process-embeddings --project-ref [project-ref]`
Alternatively verify locally with: `supabase functions serve process-embeddings --env-file .env.local`
  </verify>
  <done>
Edge function appends errors to error_details array, preserving full retry history.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update error details panel to display error history</name>
  <files>apps/api/components/DocumentManager.tsx</files>
  <action>
Update the error details section in `DocumentDetailsPanel` (around lines 242-268) to handle array format:

1. **Update Document interface** to support array error_details:
   ```typescript
   error_details?: ErrorDetail[] | ErrorDetail | null;

   // Add type alias above Document interface:
   interface ErrorDetail {
     attempt?: number;
     code?: string;
     message?: string;
     timestamp?: string;
     stage?: string;
     details?: any;
   }
   ```

2. **Normalize error_details** in the rendering section:
   ```typescript
   // Inside DocumentDetailsPanel, before rendering
   const errorHistory: ErrorDetail[] = useMemo(() => {
     if (!document.error_details) return [];
     if (Array.isArray(document.error_details)) return document.error_details;
     return [document.error_details]; // Legacy single object
   }, [document.error_details]);
   ```

3. **Update rendering** to show all attempts:
   - If single error (errorHistory.length === 1), show current format
   - If multiple errors, show each in a collapsible section or stacked cards:

   ```tsx
   {document.status === 'error' && errorHistory.length > 0 && (
     <div className="space-y-2">
       <p className="text-sm font-medium text-gray-700 dark:text-gray-300">
         Error Details {errorHistory.length > 1 && `(${errorHistory.length} attempts)`}
       </p>
       <div className="space-y-3">
         {errorHistory.map((err, idx) => (
           <div key={idx} className="bg-rose-50 dark:bg-rose-900/20 border border-rose-200 dark:border-rose-800 rounded-lg p-4 space-y-2">
             {errorHistory.length > 1 && (
               <p className="text-xs text-rose-500 dark:text-rose-400 font-semibold">
                 Attempt {err.attempt ?? idx + 1}
               </p>
             )}
             {err.message && (
               <p className="text-sm text-rose-700 dark:text-rose-300 font-medium">
                 {err.message}
               </p>
             )}
             {err.code && (
               <p className="text-xs text-rose-600 dark:text-rose-400">
                 <span className="font-medium">Code:</span> {err.code}
               </p>
             )}
             {err.stage && (
               <p className="text-xs text-rose-600 dark:text-rose-400">
                 <span className="font-medium">Failed at:</span> {err.stage}
               </p>
             )}
             {err.timestamp && (
               <p className="text-xs text-rose-600 dark:text-rose-400">
                 <span className="font-medium">Time:</span> {formatDate(err.timestamp)}
               </p>
             )}
           </div>
         ))}
       </div>
     </div>
   )}
   ```

4. **Import useMemo** if not already imported (it is, at line 3).
  </action>
  <verify>
Run dev server: `cd apps/api && npm run dev`
Navigate to /documents, click on an error document, verify error details panel displays correctly.
No TypeScript errors in DocumentManager.tsx.
  </verify>
  <done>
Error details panel shows all retry attempts with attempt numbers, making debugging recurring failures easier.
  </done>
</task>

</tasks>

<verification>
Overall phase verification:

1. **Reprocess flow works end-to-end:**
   - Upload a document that will fail (e.g., image-only PDF)
   - Verify it shows status "error" with error details
   - Click Reprocess button, confirm dialog
   - Verify status changes to "pending" immediately (realtime update)
   - Verify error_details preserved in array format
   - Wait for edge function to process
   - If fails again: verify new error appended to history (now shows 2 attempts)
   - If succeeds: verify status "embedded", chunks created

2. **Re-embed working document:**
   - Take an already "embedded" document
   - Click Reprocess
   - Verify chunks deleted and regenerated
   - Verify status flow: embedded -> pending -> processing -> embedded
   - Verify chunk_count updates correctly

3. **Error history display:**
   - Document with multiple failed attempts shows all errors in details panel
   - Each error shows attempt number, message, code, stage, timestamp
</verification>

<success_criteria>
- [ ] reprocessDocumentAction deletes chunks before resetting status
- [ ] reprocessDocumentAction resets chunk_count and processing_stage to null
- [ ] Error history preserved as array in error_details
- [ ] Edge function appends new errors to existing error history
- [ ] DocumentDetailsPanel displays multiple error attempts correctly
- [ ] Single-error documents display unchanged (backward compatible)
- [ ] E2E flow: error doc -> reprocess -> pending -> processing -> embedded
</success_criteria>

<output>
After completion, create `.planning/phases/05-error-recovery/05-01-SUMMARY.md`
</output>
