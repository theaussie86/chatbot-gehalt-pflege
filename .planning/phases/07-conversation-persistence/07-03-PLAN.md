---
phase: 07-conversation-persistence
plan: 03
type: execute
wave: 2
depends_on: ["07-01", "07-02"]
files_modified:
  - apps/web/components/DoiConsentForm.tsx
  - apps/web/components/MessageBubble.tsx
  - apps/web/App.tsx
  - apps/web/services/gemini.ts
  - apps/api/app/api/chat/route.ts
  - apps/api/app/api/email-export/route.ts
  - apps/api/lib/emailTemplate.ts
autonomous: true

user_setup:
  - service: email-provider
    why: "Sending formatted result emails to users after DOI consent"
    env_vars:
      - name: RESEND_API_KEY
        source: "Create account at resend.com -> API Keys -> Create API Key"
    dashboard_config:
      - task: "Verify sender domain or use onboarding@resend.dev for testing"
        location: "Resend Dashboard -> Domains"

must_haves:
  truths:
    - "After calculation completes, user sees inline DOI consent form with email input and marketing consent checkbox"
    - "User cannot send email without checking the consent checkbox"
    - "User receives formatted HTML email with their inputs AND calculated results"
    - "Email contains: Tarif, Stufe, Steuerklasse, Brutto, Netto, all tax breakdowns, all social security breakdowns"
    - "User email is saved to the specific salary_inquiries record (by id) in Supabase"
    - "Admin sees the email in the inquiry dashboard"
  artifacts:
    - path: "apps/web/components/DoiConsentForm.tsx"
      provides: "Inline email + consent checkbox form rendered in chat"
      exports: ["DoiConsentForm"]
    - path: "apps/api/app/api/email-export/route.ts"
      provides: "POST endpoint that sends formatted result email and updates inquiry by id"
      exports: ["POST"]
    - path: "apps/api/lib/emailTemplate.ts"
      provides: "HTML email template function for salary results"
      exports: ["buildSalaryEmail"]
  key_links:
    - from: "apps/api/app/api/chat/route.ts"
      to: "salary_inquiries"
      via: "INSERT with .select('id').single() returns inquiry id in API response"
      pattern: "\\.select\\(.*id.*\\)\\.single"
    - from: "apps/web/App.tsx"
      to: "inquiryId state"
      via: "Stores inquiry id from chat API response when section becomes completed"
      pattern: "inquiryId|setInquiryId"
    - from: "apps/web/components/DoiConsentForm.tsx"
      to: "/api/email-export"
      via: "fetch POST with email, consent, inquiryId, inquiryData"
      pattern: "fetch.*email-export"
    - from: "apps/api/app/api/email-export/route.ts"
      to: "salary_inquiries"
      via: "UPDATE email SET email WHERE id = inquiryId (precise single-row update)"
      pattern: "\\.update.*\\.eq\\('id'"
    - from: "apps/api/app/api/email-export/route.ts"
      to: "apps/api/lib/emailTemplate.ts"
      via: "buildSalaryEmail generates HTML body"
      pattern: "buildSalaryEmail"
---

<objective>
Email export with DOI (Double Opt-In) consent for completed salary calculations, with inquiry ID flowing from chat API through widget to email export for precise DB updates.

Purpose: Users can export their salary calculation results to email (CONV-06). Email capture requires explicit DOI consent via inline form with checkbox (CONV-04 email association). The email contains the full breakdown of user inputs and calculated results. The chat API returns the inquiry id on completion, which the widget stores and passes to the email export endpoint to precisely update the correct salary_inquiries row.

Output: Chat API returns inquiry id, DOI consent form component in chat widget, email export API endpoint with id-based DB update, HTML email template, email saved to inquiry record for admin visibility.
</objective>

<execution_context>
@/Users/cweissteiner/.claude/get-shit-done/workflows/execute-plan.md
@/Users/cweissteiner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-conversation-persistence/07-CONTEXT.md

# Depends on Plan 01 outputs:
@apps/web/App.tsx
@apps/web/types.ts
@apps/web/services/gemini.ts
@apps/web/components/MessageBubble.tsx

# Depends on Plan 02 outputs:
@apps/api/app/actions/inquiries.ts

# Existing references:
@apps/api/app/api/chat/route.ts
@apps/api/types/form.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Chat API returns inquiry id and widget stores it</name>
  <files>
    apps/api/app/api/chat/route.ts
    apps/web/services/gemini.ts
    apps/web/App.tsx
    apps/web/types.ts
  </files>
  <action>
This task establishes the inquiry id flow: chat API -> widget response -> widget state -> available for email export.

**1. Update `apps/api/app/api/chat/route.ts`** -- Return inquiry id on completion:

Find the section where salary_inquiries is inserted (around lines 360-375). Currently the insert does NOT return the id. Change it to:

```typescript
const saveResult = await getSupabaseAdmin()
    .from('salary_inquiries')
    .insert({
        public_key: activeProjectId,
        gruppe: jobData.group || 'P7',
        stufe: jobData.experience || '2',
        tarif: jobData.tarif || 'tvoed',
        jahr: new Date().getFullYear(),
        brutto: monthlyBrutto,
        netto: monthlyNetto,
        details: {
            ...calculationResult,
            job_details: jobData,
            tax_details: taxData
        }
    })
    .select('id')
    .single();
```

Key change: Added `.select('id').single()` to get back the inserted row's id.

Then include the inquiry id in the JSON response. Find the `NextResponse.json` call that returns the completed state (around line 392) and add `inquiryId`:

```typescript
return NextResponse.json({
    text: formattedResult + '\n\n[PROGRESS: 100]',
    formState: nextFormState,
    inquiryId: saveResult.data?.id || null
});
```

If the save failed, `inquiryId` will be null -- the email export handles this gracefully.

**2. Update `apps/web/services/gemini.ts`** -- Return inquiry id from response:

The `sendMessageToGemini` return type (already changed by Plan 01 to `{ text, formState }`) needs to also include `inquiryId`:

```typescript
export const sendMessageToGemini = async (
  userMessage: string,
  history: Message[],
  currentFormState?: FormState
): Promise<{ text: string; formState?: FormState; inquiryId?: string }>
```

In the response parsing, extract inquiryId:
```typescript
return { text: data.text || "", formState: data.formState, inquiryId: data.inquiryId };
```

**3. Update `apps/web/types.ts`** -- Add inquiryId to Message type:

The DOI form needs access to the inquiry id. Add it to the widget state. In `types.ts`, no change to Message type for this -- instead, this will be stored as top-level App state.

**4. Update `apps/web/App.tsx`** -- Store inquiry id in state:

Add state: `const [inquiryId, setInquiryId] = useState<string | null>(null);`

In `handleSendMessage`, after destructuring the sendMessageToGemini response:
```typescript
const { text: rawText, formState: newFormState, inquiryId: newInquiryId } = await sendMessageToGemini(textToSend, messages, formState);

if (newInquiryId) {
  setInquiryId(newInquiryId);
}
```

On reset (`handleReset`), clear inquiryId: `setInquiryId(null);`

This inquiry id will be passed to the DOI consent form in Task 2.
  </action>
  <verify>
Run `cd /Users/cweissteiner/NextJS/chatbot-gehalt-pflege && npm run build` to verify both apps compile. Verify:
1. Chat route's .insert() now includes `.select('id').single()`
2. Chat route's completed response includes `inquiryId` field
3. gemini.ts returns `{ text, formState, inquiryId }` from sendMessageToGemini
4. App.tsx stores inquiryId in state from API response
5. App.tsx clears inquiryId on reset
  </verify>
  <done>
Chat API returns inquiry id when saving to salary_inquiries. Widget receives and stores inquiry id in state. The id flows: DB insert -> API response -> gemini.ts -> App.tsx state -> ready for email export. Reset clears the id.
  </done>
</task>

<task type="auto">
  <name>Task 2: DOI consent form component and chat integration</name>
  <files>
    apps/web/components/DoiConsentForm.tsx
    apps/web/components/MessageBubble.tsx
    apps/web/App.tsx
    apps/web/types.ts
  </files>
  <action>
Create `apps/web/components/DoiConsentForm.tsx` as an inline form that appears in the chat after calculation completes:

```typescript
interface DoiConsentFormProps {
  onSubmit: (email: string) => void;
  isLoading: boolean;
  isSubmitted: boolean;
}
```

The form renders inside the chat message area (not as a modal or popup):
- Email input field: `<input type="email" placeholder="deine@email.de" />`
- Consent checkbox with German label:
  "Ich stimme zu, dass meine E-Mail-Adresse gespeichert wird und ich per E-Mail kontaktiert werden darf. Die Ergebniszusammenfassung wird an diese Adresse gesendet."
- Submit button: "Ergebnis per E-Mail senden" -- disabled unless:
  - Email is valid (basic email regex check)
  - Consent checkbox is checked
- Loading state: button shows spinner while sending
- Success state: Shows "E-Mail wurde gesendet!" confirmation message with a checkmark, hides the form inputs
- Error state: Shows "Fehler beim Senden. Bitte versuche es erneut." with retry option

Style the form as a card that fits within the chat flow:
- White background, rounded corners, subtle border (matching bot message style)
- Compact layout: email input full width, checkbox below, button below
- Use existing theme CSS variables for the button color
- Touch-friendly: input and button have adequate tap targets (min 44px height)

Update `apps/web/types.ts`:
- Add to the `Message` interface: `showDoiForm?: boolean;` -- flag to render the DOI form instead of/in addition to message text

Update `apps/web/components/MessageBubble.tsx`:
- Add the DOI form rendering logic. When a message has `showDoiForm: true`, render `<DoiConsentForm>` below the message text within the bot message bubble.
- Import DoiConsentForm. The props (onSubmit, isLoading, isSubmitted) will be passed through from App.tsx via additional props on MessageBubble, or render the form conditionally.
- Approach: Add optional props to MessageBubble: `doiFormProps?: { onSubmit, isLoading, isSubmitted }`. When `message.showDoiForm && doiFormProps`, render `<DoiConsentForm {...doiFormProps} />` after the message text.

Update `apps/web/App.tsx`:
- Add state for DOI form: `const [doiLoading, setDoiLoading] = useState(false);` and `const [doiSubmitted, setDoiSubmitted] = useState(false);`
- After a calculation result is received (when formState transitions to 'completed'):
  - Add a bot message with `showDoiForm: true` and text like "Mochtest du dein Ergebnis per E-Mail erhalten?"
- In the message rendering loop, detect `showDoiForm` and pass DOI form props to MessageBubble
- When DoiConsentForm's `onSubmit` fires with the email:
  - Call `sendEmailExport(email, formState, inquiryId)` (defined in Task 3's gemini.ts addition)
  - Set doiLoading/doiSubmitted state accordingly
  - The `inquiryId` from state (set in Task 1) is passed to the export function

Add `sendEmailExport` to `apps/web/services/gemini.ts`:

```typescript
export const sendEmailExport = async (
  email: string,
  inquiryData: {
    jobDetails: Record<string, any>;
    taxDetails: Record<string, any>;
    calculationResult: Record<string, any>;
  },
  projectId: string,
  inquiryId: string | null
): Promise<{ success: boolean; error?: string }> => {
  // POST to /api/email-export (derive URL from apiEndpoint config: replace /api/chat with /api/email-export)
  // Body: { email, consent: true, inquiryData, projectId, inquiryId }
  // Return { success } or { success: false, error: message }
}
```

IMPORTANT per CONTEXT.md: DOI is a hard requirement -- no email sending without explicit consent. The checkbox MUST be checked. The form validates this client-side, and the API validates it server-side.
  </action>
  <verify>
Run `cd /Users/cweissteiner/NextJS/chatbot-gehalt-pflege/apps/web && npx tsc --noEmit` to verify compilation. Verify:
1. DoiConsentForm renders email input, checkbox, and submit button
2. Submit disabled without consent checkbox checked
3. MessageBubble.tsx renders DoiConsentForm when message.showDoiForm is true
4. App.tsx shows DOI form after calculation completes
5. sendEmailExport function includes inquiryId parameter and calls /api/email-export endpoint
6. Success/error states handled in the form UI
  </verify>
  <done>
DOI consent form appears inline in chat after calculation (rendered inside MessageBubble). Email input + consent checkbox required. Submit calls /api/email-export with inquiryId for precise DB update. Success shows confirmation, error shows retry option. Form is touch-friendly and styled to match chat UI.
  </done>
</task>

<task type="auto">
  <name>Task 3: HTML email template</name>
  <files>
    apps/api/lib/emailTemplate.ts
  </files>
  <action>
Create `apps/api/lib/emailTemplate.ts` -- HTML email template builder:

```typescript
interface SalaryEmailData {
  // User inputs
  tarif?: string;
  gruppe?: string;
  stufe?: string;
  hours?: number;
  state?: string;
  taxClass?: string;
  churchTax?: boolean | string;
  numberOfChildren?: number;
  // Calculation results
  brutto: number;
  netto: number;
  taxes: {
    lohnsteuer: number;
    soli: number;
    kirchensteuer: number;
  };
  socialSecurity: {
    kv: number;
    rv: number;
    av: number;
    pv: number;
  };
  year: number;
}

export function buildSalaryEmail(data: SalaryEmailData): string {
  // Returns a complete HTML email string
}
```

The HTML email must contain (per CONTEXT.md -- "both what the user entered AND the calculated result"):
- Header: "Deine Gehaltsberechnung" with year
- Section 1: "Deine Angaben" (user inputs):
  - Tarifvertrag, Entgeltgruppe, Erfahrungsstufe, Wochenstunden, Bundesland
  - Steuerklasse, Kirchensteuer (Ja/Nein), Anzahl Kinder
- Section 2: "Berechnungsergebnis" (results):
  - Bruttogehalt (monthly)
  - Nettogehalt (monthly)
- Section 3: "Abzuge im Detail":
  - Lohnsteuer, Solidaritatszuschlag, Kirchensteuer
  - Krankenversicherung, Rentenversicherung, Arbeitslosenversicherung, Pflegeversicherung
- Footer: "Diese Berechnung wurde mit dem Pflege Gehalt Chatbot erstellt." + disclaimer that values are estimates

Format all currency as EUR using German formatting (1.234,56 EUR). Use inline CSS (email clients don't support external stylesheets). Clean, professional look with:
- Max-width 600px centered container
- Light gray background (#f5f5f5)
- White content cards
- Table layout for line items
- Primary color for headers (use hardcoded #2563eb since emails can't use CSS variables)
  </action>
  <verify>
Run `cd /Users/cweissteiner/NextJS/chatbot-gehalt-pflege/apps/api && npx tsc --noEmit` to verify TypeScript compiles. Verify:
1. `buildSalaryEmail` is exported and accepts SalaryEmailData
2. Returns a string containing valid HTML
3. HTML includes all required sections: Deine Angaben, Berechnungsergebnis, Abzuge im Detail
4. Currency values formatted with German locale
  </verify>
  <done>
HTML email template function `buildSalaryEmail` generates complete email with user inputs, calculation results, and detailed tax/social security breakdown. All German text, EUR formatting, inline CSS for email client compatibility.
  </done>
</task>

<task type="auto">
  <name>Task 4: Email export API endpoint with id-based DB update</name>
  <files>
    apps/api/app/api/email-export/route.ts
  </files>
  <action>
Create `apps/api/app/api/email-export/route.ts` -- POST endpoint:

```typescript
export async function POST(request: Request) {
  // 1. Parse body: { email, consent, inquiryData, projectId, inquiryId }
  // 2. Validate: email format, consent === true (server-side DOI check)
  // 3. Build HTML email using buildSalaryEmail(inquiryData)
  // 4. Send email via Resend (npm package "resend")
  // 5. Save email to salary_inquiries record using inquiryId (precise single-row update)
  // 6. Return { success: true } or { error: string }
}
```

Implementation details:

**Email sending via Resend:**
- Install `resend` package: The executor should run `cd apps/api && npm install resend`
- Use Resend for email sending (simple API, generous free tier, great DX):
  ```typescript
  import { Resend } from 'resend';
  const resend = new Resend(process.env.RESEND_API_KEY);

  await resend.emails.send({
    from: 'Pflege Gehalt Chatbot <noreply@yourdomain.com>',
    to: email,
    subject: `Deine Gehaltsberechnung ${new Date().getFullYear()}`,
    html: buildSalaryEmail(emailData),
  });
  ```
- If RESEND_API_KEY is not set, return error: "Email service not configured"
- From address: Use `onboarding@resend.dev` for development, configure real domain later

**Save email to inquiry record using inquiry id (CRITICAL):**
- Do NOT use `.update().order().limit()` -- this is not a valid Supabase JS query chain and would either update all matching rows or fail.
- Instead, use the `inquiryId` passed from the widget to precisely identify the row:
  ```typescript
  import { getSupabaseAdmin } from '../../../utils/supabase/admin';
  // or: import { createClient } from '@supabase/supabase-js';

  const supabase = getSupabaseAdmin();
  // Use the service role admin client (bypasses RLS, backend-only operation)

  if (inquiryId) {
    const { error: updateError } = await supabase
      .from('salary_inquiries')
      .update({ email })
      .eq('id', inquiryId);

    if (updateError) {
      console.error('[EmailExport] Failed to save email:', updateError);
      // Don't fail the request -- email was already sent successfully
    }
  }
  ```
- If `inquiryId` is null (save failed during chat), log a warning but still send the email. The email delivery is the primary purpose; the DB association is secondary.

**Request body validation:**
```typescript
const body = await request.json();
const { email, consent, inquiryData, projectId, inquiryId } = body;

// Validate consent (server-side DOI check)
if (consent !== true) {
  return NextResponse.json({ error: "Consent required" }, { status: 400 });
}

// Validate email format
const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
if (!email || !emailRegex.test(email)) {
  return NextResponse.json({ error: "Invalid email" }, { status: 400 });
}
```

**Rate limiting:** Reuse the same IP-based rate limiting pattern from the chat route (check request_logs table). Limit email sends to 5 per IP per 60 seconds to prevent abuse.

**CORS:** Add OPTIONS handler matching the chat route pattern. Allow the widget origin.

**Security:**
- Validate email format server-side (regex)
- Require `consent === true` in the request body
- Rate limit to prevent spam
- Don't expose internal errors to client

Add `RESEND_API_KEY` to the environment check. If missing, the endpoint returns 503 with "Email service not configured" (graceful degradation).
  </action>
  <verify>
1. Run `cd /Users/cweissteiner/NextJS/chatbot-gehalt-pflege/apps/api && npm install resend` to install dependency
2. Run `npm run build` to verify compilation
3. Verify `POST /api/email-export` endpoint exists
4. Verify request body includes `inquiryId` field
5. Verify DB update uses `.eq('id', inquiryId)` -- NOT `.order().limit()`
6. Verify consent is validated server-side
7. Verify rate limiting is applied
8. Verify CORS OPTIONS handler exists
  </verify>
  <done>
Email export endpoint at `/api/email-export` sends formatted HTML email via Resend. Uses `inquiryId` from request body for precise single-row DB update (`.update({ email }).eq('id', inquiryId)`). Consent validated server-side. Rate limited. CORS configured. Graceful degradation if RESEND_API_KEY not set or inquiryId is null.
  </done>
</task>

</tasks>

<verification>
1. Build succeeds for both apps (web widget and API)
2. Chat API returns inquiryId in response when saving to salary_inquiries
3. Widget stores inquiryId in state and passes to email export
4. DOI consent form appears after calculation completes in chat (rendered in MessageBubble)
5. Form validates email format and consent checkbox
6. POST /api/email-export sends HTML email via Resend
7. Email contains both user inputs AND calculated results
8. Email saved to salary_inquiries record using .eq('id', inquiryId) -- precise update
9. Rate limiting prevents email spam
10. Graceful degradation if RESEND_API_KEY not configured or inquiryId is null
</verification>

<success_criteria>
- CONV-06: User exports conversation/result to email after providing consent
- CONV-04: User email saved to specific salary_inquiries record (by id) and visible in admin dashboard
- DOI hard requirement met: no email sent without explicit consent checkbox
- Email contains ALL required data: user inputs (Tarif, Stufe, Steuerklasse, hours, state) + full breakdown (Brutto, Netto, Lohnsteuer, Soli, Kirchensteuer, KV, RV, AV, PV)
- Inquiry ID flows: chat API insert with .select('id').single() -> API response -> widget state -> email export request -> .eq('id', inquiryId) DB update
- Rate limiting prevents abuse
</success_criteria>

<output>
After completion, create `.planning/phases/07-conversation-persistence/07-03-SUMMARY.md`
</output>
