---
phase: 07-conversation-persistence
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/web/services/conversationStore.ts
  - apps/web/services/gemini.ts
  - apps/web/App.tsx
  - apps/web/components/StepBar.tsx
  - apps/web/components/ProgressBar.tsx
  - apps/web/types.ts
autonomous: true

must_haves:
  truths:
    - "User reloads page and sees full conversation history within 1 second"
    - "User closes browser, reopens days later, and conversation resumes from last state"
    - "User sees 4-step progress bar with labels: Jobdaten, Steuerdaten, Ubersicht, Ergebnis"
    - "User can click 'Neues Gesprach' button to reset conversation mid-flow"
    - "On conversation completion, local storage is cleared"
  artifacts:
    - path: "apps/web/services/conversationStore.ts"
      provides: "Client-side conversation persistence using localStorage"
      exports: ["ConversationStore"]
    - path: "apps/web/components/StepBar.tsx"
      provides: "Horizontal 4-step progress bar with German labels"
      exports: ["StepBar"]
    - path: "apps/web/App.tsx"
      provides: "Updated chat app with persistence and step bar integration"
      min_lines: 100
  key_links:
    - from: "apps/web/App.tsx"
      to: "apps/web/services/conversationStore.ts"
      via: "useEffect on mount to load saved conversation, save on each message"
      pattern: "ConversationStore\\.(load|save|clear)"
    - from: "apps/web/App.tsx"
      to: "apps/web/components/StepBar.tsx"
      via: "formState.section drives step bar rendering"
      pattern: "StepBar.*section"
    - from: "apps/web/services/gemini.ts"
      to: "formState"
      via: "API request includes currentFormState, response returns updated formState"
      pattern: "currentFormState|formState"
---

<objective>
Client-side conversation persistence and step progress indicator for the chat widget.

Purpose: Users can resume conversations across page refreshes and browser sessions (CONV-01, CONV-02). Users see a visual 4-step progress bar showing where they are in the salary interview (CONV-05). This is the foundation for the conversation experience -- without persistence, every page reload loses the entire interview.

Output: Conversation storage service, updated widget App with auto-resume and "Neues Gesprach" button, StepBar component replacing the existing percentage ProgressBar.
</objective>

<execution_context>
@/Users/cweissteiner/.claude/get-shit-done/workflows/execute-plan.md
@/Users/cweissteiner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-conversation-persistence/07-CONTEXT.md

@apps/web/App.tsx
@apps/web/types.ts
@apps/web/services/gemini.ts
@apps/web/components/ProgressBar.tsx
@apps/web/components/MessageBubble.tsx
@apps/api/types/form.ts
@apps/api/lib/salary-flow.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Conversation storage service and widget integration</name>
  <files>
    apps/web/services/conversationStore.ts
    apps/web/services/gemini.ts
    apps/web/App.tsx
    apps/web/types.ts
  </files>
  <action>
Create `apps/web/services/conversationStore.ts` as a localStorage-based conversation store with the following API:

```typescript
interface StoredConversation {
  messages: Message[];        // Full message history
  formState: FormState;       // Current form state (section, data, missingFields)
  progress: number;           // Progress percentage
  updatedAt: string;          // ISO timestamp for staleness detection
}

class ConversationStore {
  static STORAGE_KEY = 'pflege-chat-conversation';

  static save(data: StoredConversation): void
  // Save with try-catch for quota exceeded. On QuotaExceededError, log warning and continue (don't crash).
  // Use JSON.stringify. Debounce is NOT needed here -- we call save explicitly after each message exchange.

  static load(): StoredConversation | null
  // Return null if no data, corrupted JSON, or missing required fields.
  // Parse timestamps back into Date objects for messages.

  static clear(): void
  // Remove the storage key entirely.

  static exists(): boolean
  // Quick check if conversation data exists.
}
```

Key implementation details:
- Use `localStorage` (NOT Dexie.js -- the research suggested it, but for a single conversation with <100 messages, localStorage is simpler and sufficient. Dexie would be over-engineering.)
- Store key: `pflege-chat-conversation`
- The `Message` type from `types.ts` needs a `timestamp` that survives JSON serialization. Currently `timestamp: Date` -- when loading, parse it back: `new Date(msg.timestamp)`.
- FormState type: duplicate the essential fields from `apps/api/types/form.ts` into `apps/web/types.ts` since the widget is a separate Vite app that cannot import from the API app. Add this interface to `types.ts`:

```typescript
export interface FormState {
  section: 'job_details' | 'tax_details' | 'summary' | 'completed';
  data: {
    job_details?: Record<string, any>;
    tax_details?: Record<string, any>;
    calculation_result?: Record<string, any>;
  };
  missingFields: string[];
  conversationContext?: string[];
  userIntent?: string;
  validationErrors?: Record<string, string>;
}
```

Update `apps/web/services/gemini.ts`:
- The `sendMessageToGemini` function currently does NOT send `currentFormState`. It must now accept and send it. Change signature to:
  ```typescript
  export const sendMessageToGemini = async (
    userMessage: string,
    history: Message[],
    currentFormState?: FormState
  ): Promise<{ text: string; formState?: FormState }>
  ```
- Send `currentFormState` in the request body alongside `message`, `history`, `projectId`.
- Parse the response to return both `text` and `formState` (the API already returns `{ text, formState }`).
- Currently returns just a string. Change return type to `{ text: string; formState?: FormState }`.

Update `apps/web/App.tsx`:
- Add state: `const [formState, setFormState] = useState<FormState | null>(null);`
- On mount (useEffect), call `ConversationStore.load()`. If data exists:
  - Set `messages` from stored data (with Date parsing)
  - Set `formState` from stored data
  - Set `progress` from stored data
  - This is the "auto-resume" -- silent, no prompt, user sees their conversation as if they never left
- After each successful API response in `handleSendMessage`:
  - Update `formState` from the API response
  - Call `ConversationStore.save({ messages: updatedMessages, formState: updatedFormState, progress: newProgress, updatedAt: new Date().toISOString() })`
- When `formState.section === 'completed'`:
  - Call `ConversationStore.clear()` -- completed conversations don't need local persistence (they're saved in Supabase via the API)
- Update `handleReset`:
  - Remove `window.confirm` -- replace with immediate reset
  - Call `ConversationStore.clear()`
  - Reset all state to initial values (initial message, null formState, 0 progress)
  - Do NOT reload the page -- just reset React state
- Replace the existing RefreshCw icon button with a clearly labeled "Neues Gesprach" button in the header. Use text + icon, not just icon. Style it as a small outline button that's clearly visible.
- Pass `formState` to `sendMessageToGemini` in `handleSendMessage`.

IMPORTANT: The existing `sendMessageToGemini` returns a string. All callers in `App.tsx` parse this string via `parseResponse`. After changing the return type to `{ text, formState }`, update the caller in `handleSendMessage` to destructure the response and extract both text and formState.
  </action>
  <verify>
Run `cd /Users/cweissteiner/NextJS/chatbot-gehalt-pflege && npm run build` (or `cd apps/web && npx tsc --noEmit`) to verify TypeScript compiles without errors. Manually verify:
1. `conversationStore.ts` exports ConversationStore class
2. `gemini.ts` sends currentFormState and returns { text, formState }
3. `App.tsx` loads/saves conversation on mount/message
4. `App.tsx` clears storage on completed state
5. "Neues Gesprach" button visible in header
  </verify>
  <done>
Widget compiles. ConversationStore saves/loads/clears conversation data. App.tsx auto-resumes on mount, persists after each message, and clears on completion. "Neues Gesprach" button resets without page reload. FormState flows from API response through the widget.
  </done>
</task>

<task type="auto">
  <name>Task 2: Step bar progress indicator</name>
  <files>
    apps/web/components/StepBar.tsx
    apps/web/components/ProgressBar.tsx
    apps/web/App.tsx
  </files>
  <action>
Create `apps/web/components/StepBar.tsx` as a horizontal 4-step progress bar:

```typescript
interface StepBarProps {
  currentSection: 'job_details' | 'tax_details' | 'summary' | 'completed';
}
```

The step bar has 4 steps with German labels (from CONTEXT.md):
1. **Jobdaten** (maps to `job_details`)
2. **Steuerdaten** (maps to `tax_details`)
3. **Ubersicht** (maps to `summary`)
4. **Ergebnis** (maps to `completed`)

Visual design:
- Horizontal bar with 4 labeled steps connected by lines
- Each step is a small circle (or numbered circle) with a label below
- States: `completed` (filled circle, primary color), `current` (outlined circle with pulse/ring, primary color), `upcoming` (gray circle)
- Connecting lines between circles: solid primary color for completed sections, gray for upcoming
- Use CSS variables from the existing theme (`var(--primary-color)`, `var(--primary-light)`)
- Display-only -- NOT interactive/clickable (per CONTEXT.md)
- Compact: fits in a narrow horizontal strip. Labels are small text (text-xs)
- Use Tailwind classes. No external dependencies.

Determine step state based on `currentSection`:
- If `currentSection` is `job_details`: step 1 is current, steps 2-4 are upcoming
- If `currentSection` is `tax_details`: step 1 is completed, step 2 is current, steps 3-4 are upcoming
- If `currentSection` is `summary`: steps 1-2 are completed, step 3 is current, step 4 is upcoming
- If `currentSection` is `completed`: all 4 steps are completed

Update `apps/web/App.tsx`:
- Replace the existing ProgressBar usage with StepBar:
  - Remove the progress bar area that shows "Fortschritt" percentage and `<ProgressBar progress={progress} />`
  - Replace with `<StepBar currentSection={formState?.section || 'job_details'} />`
  - Keep the same container div location (between header and chat area) with appropriate padding

The existing `ProgressBar.tsx` can remain in the codebase (it's not harmful) but should no longer be imported or used in App.tsx. Do NOT delete it -- it might be useful elsewhere later.

IMPORTANT: The step bar must use the existing theme CSS variables. Check the `themeStyles` object in App.tsx that sets `--primary-color` etc. The StepBar inherits these because it's rendered inside the themed container div.
  </action>
  <verify>
Run `cd /Users/cweissteiner/NextJS/chatbot-gehalt-pflege/apps/web && npx tsc --noEmit` to verify TypeScript compiles. Verify:
1. StepBar renders 4 labeled steps in German
2. Step states correctly derive from currentSection prop
3. App.tsx uses StepBar instead of ProgressBar
4. No ProgressBar import remains in App.tsx
  </verify>
  <done>
StepBar component renders 4 German-labeled steps (Jobdaten, Steuerdaten, Ubersicht, Ergebnis) that highlight based on the current form section. Replaced ProgressBar in App.tsx. Steps are display-only, styled with theme CSS variables, and compact.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `cd apps/web && npx tsc --noEmit` passes
2. Build succeeds: `cd apps/web && npm run build` passes
3. ConversationStore.save/load/clear roundtrips correctly (save data, load returns same data, clear removes it)
4. StepBar shows correct step states for each section value
5. App.tsx no longer uses ProgressBar, uses StepBar instead
6. FormState is sent to and received from the chat API
</verification>

<success_criteria>
- CONV-01: Conversation persists in localStorage across page refreshes (ConversationStore.save called after each message, ConversationStore.load on mount)
- CONV-02: Auto-resume works silently (load on mount populates messages + formState + progress)
- CONV-05: 4-step StepBar with German labels replaces percentage ProgressBar
- "Neues Gesprach" button resets conversation without page reload
- Completed conversations clear local storage
</success_criteria>

<output>
After completion, create `.planning/phases/07-conversation-persistence/07-01-SUMMARY.md`
</output>
