---
phase: 04-edge-function-processing
plan: 03
type: execute
wave: 3
depends_on: ["02"]
files_modified:
  - supabase/functions/process-embeddings/index.ts
autonomous: true

must_haves:
  truths:
    - "Semantic chunking respects document structure (paragraphs/sections)"
    - "Chunk size targets 1000-3000 characters with ~100 char overlap"
    - "Text extraction validates content is not empty or image-only"
    - "Spreadsheets are converted to markdown table format"
  artifacts:
    - path: "supabase/functions/process-embeddings/index.ts"
      provides: "Improved chunking and file type handling"
      contains: "RecursiveCharacterTextSplitter"
  key_links:
    - from: "supabase/functions/process-embeddings/index.ts"
      to: "Gemini text extraction"
      via: "generateContent with extraction prompt"
      pattern: "contains only images|scanned"
---

<objective>
Implement improved chunking strategy and file type handling per CONTEXT.md decisions.

Purpose: The current chunking uses fixed 1000/200 settings. CONTEXT.md specifies semantic chunking with 1000-3000 chars and 100 char overlap. Also need to handle spreadsheets and detect image-only PDFs.

Output: Edge function with improved chunking configuration and file type handling.
</objective>

<execution_context>
@/Users/cweissteiner/.claude/get-shit-done/workflows/execute-plan.md
@/Users/cweissteiner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/04-edge-function-processing/04-CONTEXT.md

@supabase/functions/process-embeddings/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update chunking configuration per CONTEXT.md</name>
  <files>supabase/functions/process-embeddings/index.ts</files>
  <action>
Update the text splitter configuration to match CONTEXT.md decisions.

**Step 1: Update chunking parameters**

Find the RecursiveCharacterTextSplitter initialization and update to match CONTEXT.md:
```typescript
// CONTEXT.md: Target chunk size 1000-3000 chars, ~100 char overlap
const splitter = new RecursiveCharacterTextSplitter({
  chunkSize: 2000,        // Target middle of 1000-3000 range
  chunkOverlap: 100,      // ~100 char overlap per CONTEXT.md
  separators: [
    "\n\n",   // Paragraph breaks first (semantic)
    "\n",     // Line breaks
    ". ",     // Sentences
    ", ",     // Clauses
    " ",      // Words
    ""        // Characters (last resort)
  ],
});
```

**Step 2: Add content validation after text extraction**

After extracting text from the document, validate we got meaningful content:
```typescript
const textContent = extractResult.text || "";
console.log(`Extracted text length: ${textContent.length}`);

// Validate we got meaningful content
if (!textContent || textContent.trim().length < 50) {
  throw new Error(
    "No text extracted from document. " +
    "This may be a scanned PDF containing only images. " +
    "Please upload a text-based PDF."
  );
}
```

**Step 3: Add minimum chunk validation**

After splitting text into chunks, validate we got results:
```typescript
const chunks = await splitter.splitText(textContent);
console.log(`Generated ${chunks.length} chunks`);

if (chunks.length === 0) {
  throw new Error("Document produced no chunks after splitting");
}
```
  </action>
  <verify>
- Confirm chunkSize is 2000 (middle of 1000-3000 range)
- Confirm chunkOverlap is 100 (per CONTEXT.md)
- Confirm separators prioritize paragraph breaks ("\n\n" first)
- Confirm content validation checks for minimum 50 chars
- Confirm chunk count is logged
  </verify>
  <done>
- Chunking uses 2000 char size with 100 char overlap
- Separators prioritize semantic breaks (paragraphs, then lines, then sentences)
- Empty/image-only documents detected with clear error message
  </done>
</task>

<task type="auto">
  <name>Task 2: Add file type specific handling</name>
  <files>supabase/functions/process-embeddings/index.ts</files>
  <action>
Implement file type handling per CONTEXT.md decisions.

**Step 1: Add supported MIME types constant**

Add this constant near the top of the file (after imports):
```typescript
const SUPPORTED_MIME_TYPES = [
  'application/pdf',
  'text/plain',
  'text/markdown',
  'text/csv',
  'application/vnd.ms-excel',
  'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
] as const;

type SupportedMimeType = typeof SUPPORTED_MIME_TYPES[number];
```

**Step 2: Add MIME type validation**

Early in the processing flow, after getting the file blob, validate the MIME type:
```typescript
const mimeType = fileBlob.type || document.mime_type;

if (!SUPPORTED_MIME_TYPES.includes(mimeType as SupportedMimeType)) {
  throw new Error(
    `Unsupported file type: ${mimeType}. ` +
    `Supported formats: PDF, plain text (.txt, .md), spreadsheets (.csv, .xlsx)`
  );
}
```

**Step 3: Create extraction prompt customization function**

Add a helper function to customize the extraction prompt based on file type:
```typescript
function getExtractionPrompt(mimeType: string): string {
  if (mimeType.includes('spreadsheet') || mimeType.includes('excel') || mimeType === 'text/csv') {
    return `Extract all content from this spreadsheet.
Convert tables to markdown table format with | separators.
Preserve headers and data structure.
Return only the extracted content, no explanations.`;
  }

  return `Extract all the text from this document.
Return only the text content.
Do not include any markdown formatting or introductory text, just the raw content.`;
}
```

**Step 4: Use the extraction prompt in generateContent call**

Update the Gemini generateContent call to use the customized prompt:
```typescript
const extractionPrompt = getExtractionPrompt(mimeType);

const extractResult = await genAI.models.generateContent({
  model: GEMINI_MODEL_EXTRACT,
  contents: [
    {
      parts: [
        {
          fileData: {
            mimeType: uploadedFile.file.mimeType,
            fileUri: uploadedFile.file.uri,
          },
        },
        {
          text: extractionPrompt,
        },
      ],
    },
  ],
});
```

**Step 5: Add image-only PDF detection heuristic**

After text extraction, add a heuristic to detect image-only PDFs:
```typescript
const textContent = extractResult.text || "";

// Heuristic: If extracted text is very short relative to file size,
// it's likely an image-only PDF
const bytesPerChar = fileBlob.size / Math.max(textContent.length, 1);
if (bytesPerChar > 1000 && textContent.trim().length < 100) {
  throw new Error(
    "This PDF appears to contain only images. " +
    "Text-based PDFs are required for embedding. " +
    "Please upload a PDF with selectable text."
  );
}
```
  </action>
  <verify>
- Confirm SUPPORTED_MIME_TYPES includes PDF, text, markdown, CSV, Excel formats
- Confirm MIME type validation happens early with clear error message
- Confirm getExtractionPrompt function exists and returns different prompts for spreadsheets
- Confirm spreadsheets get markdown table extraction prompt
- Confirm image-only PDF detection uses bytes-per-char heuristic (>1000 bytes/char AND <100 chars)
  </verify>
  <done>
- Supported file types validated with clear error for unsupported
- Spreadsheets converted to markdown table format via custom prompt
- Image-only PDFs detected with helpful error message
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **Code review**: Verify:
   - Chunk size is 2000 with 100 overlap
   - Separators start with `\n\n` (paragraphs)
   - SUPPORTED_MIME_TYPES constant exists
   - MIME type validation at start of processing
   - getExtractionPrompt function with spreadsheet-specific prompt
   - Image-only PDF detection heuristic

2. **Error messages**: Verify error messages are user-friendly:
   - "scanned PDF containing only images" message
   - "Unsupported file type" with list of supported formats
</verification>

<success_criteria>
- Chunking: 2000 char size, 100 char overlap, paragraph-first separators
- File validation: PDF, text, markdown, CSV, XLSX supported
- Spreadsheets: Converted to markdown table format
- Image-only PDFs: Detected with clear error message
- All error messages are technical enough for debugging
</success_criteria>

<output>
After completion, create `.planning/phases/04-edge-function-processing/04-03-SUMMARY.md`
</output>
