---
phase: 04-edge-function-processing
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - supabase/functions/process-embeddings/index.ts
autonomous: true

must_haves:
  truths:
    - "Embedding API response is parsed defensively with multiple fallback paths"
    - "Batch embedding failures don't kill entire document processing"
    - "Document processing fails completely if any chunk fails (all-or-nothing per CONTEXT.md)"
    - "Status updates show processing stage (extracting text / embedding chunks)"
  artifacts:
    - path: "supabase/functions/process-embeddings/index.ts"
      provides: "Defensive embedding parsing and improved batch handling"
      contains: "Promise.allSettled"
  key_links:
    - from: "supabase/functions/process-embeddings/index.ts"
      to: "Gemini Embedding API"
      via: "genAI.models.embedContent"
      pattern: "embedding\\.values.*embeddings\\[0\\]\\.values"
    - from: "supabase/functions/process-embeddings/index.ts"
      to: "documents table"
      via: "supabase.update"
      pattern: "processing.*extracting|processing.*embedding"
---

<objective>
Implement defensive embedding response parsing and improve batch processing to handle partial failures gracefully.

Purpose: The embedding API response structure varies between SDK versions. Current code assumes `embeddings[0].values` but may receive `embedding.values`. Additionally, Promise.all cascades failures - one failed chunk kills the batch.

Output: Edge function with defensive response parsing and Promise.allSettled for batch processing, with all-or-nothing document failure semantics.
</objective>

<execution_context>
@/Users/cweissteiner/.claude/get-shit-done/workflows/execute-plan.md
@/Users/cweissteiner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/04-edge-function-processing/04-CONTEXT.md
@.planning/research/PITFALLS.md

@supabase/functions/process-embeddings/index.ts
@apps/api/lib/vectorstore/VectorstoreService.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement defensive embedding response parsing</name>
  <files>supabase/functions/process-embeddings/index.ts</files>
  <action>
Implement EDGE-01: Parse embedding API response defensively to handle structure variations.

1. **Create a helper function** to extract embedding values with multiple fallback paths:
```typescript
function extractEmbeddingValues(embedResult: any): number[] | null {
  // Try multiple response formats (SDK version variations)
  const values =
    embedResult?.embedding?.values ||        // v1.x format (singular)
    embedResult?.embeddings?.[0]?.values ||  // v0.x format (array)
    embedResult?.values ||                    // Direct format
    null;

  // Validate the result
  if (!values || !Array.isArray(values) || values.length === 0) {
    console.error('Invalid embedding response structure:', JSON.stringify(embedResult, null, 2));
    return null;
  }

  // Validate dimension (text-embedding-004 should be 768)
  if (values.length !== 768) {
    console.warn(`Unexpected embedding dimension: ${values.length} (expected 768)`);
  }

  return values;
}
```

2. **Replace the current embedding extraction** (around line 142):
```typescript
// OLD:
const values = embedResult.embeddings?.[0]?.values;
if (!values) return null;

// NEW:
const values = extractEmbeddingValues(embedResult);
if (!values) {
  throw new Error(`Failed to extract embedding for chunk ${i + batchIndex}: invalid response structure`);
}
```

3. **Add logging before extraction** to help debug issues:
```typescript
console.log(`Embedding chunk ${i + batchIndex}/${chunks.length}`);
```
  </action>
  <verify>
- Confirm `extractEmbeddingValues` helper function exists
- Confirm it checks `embedding.values`, `embeddings[0].values`, and `values` paths
- Confirm it validates array and non-empty
- Confirm it logs the full response on failure for debugging
  </verify>
  <done>
- Embedding response parsing uses multiple fallback paths
- Invalid responses are logged with full structure for debugging
- Dimension validation warns on unexpected sizes
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Promise.allSettled with all-or-nothing semantics</name>
  <files>supabase/functions/process-embeddings/index.ts</files>
  <action>
Implement EDGE-02: Use Promise.allSettled for batch processing, but maintain all-or-nothing document processing per CONTEXT.md decision.

1. **Update status to show processing stage** before embedding starts:
```typescript
// Before text extraction
currentStage = 'extracting_text';
await supabase
  .from("documents")
  .update({ status: "processing", processing_stage: "extracting text" })
  .eq("id", documentId);

// Before embedding
currentStage = 'embedding';
await supabase
  .from("documents")
  .update({ processing_stage: "embedding chunks" })
  .eq("id", documentId);
```

2. **Replace Promise.all with Promise.allSettled** in the batch processing loop:
```typescript
const batchResults = await Promise.allSettled(batchPromises);

// Separate successful and failed results
const successful: typeof chunkDataArray = [];
const failed: { index: number; error: string }[] = [];

for (const result of batchResults) {
  if (result.status === 'fulfilled' && result.value !== null) {
    successful.push(result.value);
  } else if (result.status === 'rejected') {
    failed.push({
      index: result.reason?.index ?? -1,
      error: result.reason?.message ?? 'Unknown error'
    });
  } else if (result.status === 'fulfilled' && result.value === null) {
    // extractEmbeddingValues returned null (logged already)
    failed.push({
      index: -1,
      error: 'Invalid embedding response structure'
    });
  }
}
```

3. **Implement all-or-nothing failure semantics** per CONTEXT.md:
```typescript
// ALL-OR-NOTHING: If ANY chunk fails, fail the entire document
if (failed.length > 0) {
  throw new Error(
    `Embedding failed for ${failed.length} of ${batch.length} chunks in batch. ` +
    `First failure: ${failed[0].error}`
  );
}

chunkDataArray.push(...successful);
```

4. **Update the batch processing to pass index in errors**:
```typescript
const batchPromises = batch.map(async (chunkText, batchIndex) => {
  const absoluteIndex = i + batchIndex;
  try {
    const embedResult = await genAI.models.embedContent({
      model: GEMINI_MODEL_EMBED,
      contents: chunkText,
    });

    const values = extractEmbeddingValues(embedResult);
    if (!values) {
      return null; // Will be caught as failure
    }

    return {
      document_id: documentId,
      chunk_index: absoluteIndex,
      content: chunkText,
      embedding: values,
      token_count: Math.ceil(chunkText.length / 4)
    };
  } catch (e) {
    console.error(`Failed to embed chunk ${absoluteIndex}:`, e);
    const error = e as Error;
    error.index = absoluteIndex; // Attach index for error reporting
    throw error;
  }
});
```

5. **Add chunk count to final status update**:
```typescript
await supabase
  .from("documents")
  .update({
    status: "embedded",
    chunk_count: chunkDataArray.length,
    processing_stage: null // Clear processing stage on completion
  })
  .eq("id", documentId);
```
  </action>
  <verify>
- Confirm Promise.allSettled is used (not Promise.all)
- Confirm failed chunks cause entire document to fail (all-or-nothing)
- Confirm status updates show "extracting text" and "embedding chunks" stages
- Confirm chunk_count is stored on successful completion
  </verify>
  <done>
- Promise.allSettled used for batch processing
- All-or-nothing semantics: any chunk failure fails the document
- Processing stage visible in status updates
- Chunk count stored in documents table on success
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **Code review**: Verify the edge function has:
   - `extractEmbeddingValues` helper with 3 fallback paths
   - `Promise.allSettled` (not `Promise.all`)
   - All-or-nothing failure check (if failed.length > 0, throw)
   - Status updates with processing_stage field

2. **Pattern check**: The batch processing should follow:
```
for each batch:
  Promise.allSettled(batchPromises)
  check for failures -> throw if any
  accumulate successful results
```

3. **Verify status flow**: processing (extracting text) -> processing (embedding chunks) -> embedded/error
</verification>

<success_criteria>
- Embedding response parsing handles v0.x and v1.x SDK formats
- Promise.allSettled used instead of Promise.all
- Any chunk failure fails the entire document (all-or-nothing)
- Processing stage shown during execution (visible in realtime UI)
- Chunk count stored on successful completion
</success_criteria>

<output>
After completion, create `.planning/phases/04-edge-function-processing/04-02-SUMMARY.md`
</output>
