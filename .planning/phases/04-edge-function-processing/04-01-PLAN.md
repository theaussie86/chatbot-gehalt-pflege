---
phase: 04-edge-function-processing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/functions/process-embeddings/index.ts
autonomous: true

must_haves:
  truths:
    - "Edge function downloads file from storage successfully"
    - "Blob MIME type accessed correctly (fileBlob.type not .mime_type)"
    - "Gemini files are cleaned up even when function crashes"
    - "Document status updates to error with details on any failure"
  artifacts:
    - path: "supabase/functions/process-embeddings/index.ts"
      provides: "Fixed edge function with proper error handling and cleanup"
      contains: "finally"
  key_links:
    - from: "supabase/functions/process-embeddings/index.ts"
      to: "Supabase Storage"
      via: "supabase.storage.from('project-files').download()"
      pattern: "fileBlob\\.type"
    - from: "supabase/functions/process-embeddings/index.ts"
      to: "Gemini Files API"
      via: "genAI.files.delete in finally block"
      pattern: "finally.*files\\.delete"
---

<objective>
Fix critical bugs in edge function: Blob MIME type access, error handling, and Gemini file cleanup.

Purpose: The current edge function has P0 bugs that prevent chunks from being created. This plan fixes the foundational issues before implementing batch embedding improvements.

Output: Edge function that properly handles file downloads, updates document status on errors, and cleans up Gemini files in all cases.
</objective>

<execution_context>
@/Users/cweissteiner/.claude/get-shit-done/workflows/execute-plan.md
@/Users/cweissteiner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/04-edge-function-processing/04-CONTEXT.md
@.planning/research/PITFALLS.md

@supabase/functions/process-embeddings/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix Blob MIME type access and request body handling</name>
  <files>supabase/functions/process-embeddings/index.ts</files>
  <action>
Fix the P0 bugs identified in PITFALLS.md:

1. **Blob MIME type** (line 77-82): Change `fileBlob.mime_type` to `fileBlob.type`. JavaScript Blob objects have `.type` property, not `.mime_type`. Add fallback to `document.mime_type` from the DB record.

2. **Request body re-parsing** (lines 199-206): The error handler tries to call `req.json()` again after it was already consumed at line 37. Fix by:
   - Storing `documentId` in a variable at the top of the try block after parsing
   - Using that stored ID in the catch block instead of re-parsing

3. **Store document ID early**: Immediately after `const payload = await req.json()`, extract and store `const documentId = payload.record.id` so it's available in catch block.

4. **Update error handling** to use the stored documentId and also store error details in the `error_details` JSONB column:
```typescript
await supabase
  .from("documents")
  .update({
    status: "error",
    error_details: {
      code: "PROCESSING_ERROR",
      message: error.message,
      timestamp: new Date().toISOString(),
      stage: currentStage // track where it failed
    }
  })
  .eq("id", documentId);
```

5. **Add stage tracking**: Add a `let currentStage = 'init'` variable that gets updated as processing progresses ("downloading", "uploading_gemini", "extracting_text", "chunking", "embedding", "inserting") so errors show where they occurred.
  </action>
  <verify>
- Read the modified file and confirm:
  - `fileBlob.type` is used instead of `fileBlob.mime_type`
  - `documentId` is stored before any processing
  - Error handler uses stored `documentId`, not re-parsed request
  - `error_details` JSONB is populated with code, message, timestamp, stage
  </verify>
  <done>
- Blob MIME type accessed via `.type` property with fallback
- Error handling uses pre-stored documentId
- Error details include processing stage information
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Gemini file cleanup in finally block</name>
  <files>supabase/functions/process-embeddings/index.ts</files>
  <action>
Implement EDGE-03: Gemini file cleanup must happen even when the function crashes.

1. **Move uploadResult to outer scope**: Declare `let uploadedFile: { file: { name: string; uri: string; mimeType: string } } | null = null` before the try block.

2. **Store uploaded file reference**: After successful upload to Gemini, store the result: `uploadedFile = uploadResult`

3. **Add finally block**: After the catch block, add:
```typescript
} finally {
  // EDGE-03: Always cleanup Gemini files, even on error
  if (uploadedFile?.file?.name) {
    try {
      await genAI.files.delete({ name: uploadedFile.file.name });
      console.log(`Cleaned up Gemini file: ${uploadedFile.file.name}`);
    } catch (cleanupError) {
      // Log but don't throw - we don't want cleanup failure to mask the original error
      console.warn(`Failed to cleanup Gemini file ${uploadedFile.file.name}:`, cleanupError);
    }
  }
}
```

4. **Remove duplicate cleanup**: Remove the existing cleanup try-catch at lines 173-178 since the finally block now handles it.

5. **Update the function structure** to be:
```typescript
Deno.serve(async (req) => {
  let documentId: string | null = null;
  let uploadedFile = null;
  let currentStage = 'init';

  const supabase = createClient(...);

  try {
    // ... all processing
  } catch (error) {
    // ... error handling using documentId
    return new Response(...);
  } finally {
    // ... Gemini cleanup
  }

  return new Response(...);
});
```
  </action>
  <verify>
- Confirm `finally` block exists with Gemini file cleanup
- Confirm cleanup uses try-catch to avoid masking original errors
- Confirm old cleanup code at lines 173-178 is removed
- Confirm uploadedFile is declared outside try block
  </verify>
  <done>
- Gemini files are cleaned up in finally block (even on error)
- Cleanup failures are logged but don't throw
- Function structure follows try/catch/finally pattern
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **Code review**: Read the full edge function and verify:
   - No references to `fileBlob.mime_type` (should all be `fileBlob.type`)
   - `documentId` declared before try block and stored immediately after parsing
   - `finally` block exists with Gemini cleanup
   - Error updates include `error_details` JSONB with stage information

2. **Syntax check**: The TypeScript code should be valid (no syntax errors)

3. **Pattern check**: Verify the structure follows:
```
let documentId, uploadedFile, currentStage
try { ... processing ... }
catch { ... error handling with documentId ... }
finally { ... Gemini cleanup ... }
```
</verification>

<success_criteria>
- Blob MIME type bug fixed (uses .type not .mime_type)
- Request body not re-parsed in error handler
- Error details include processing stage
- Gemini files always cleaned up (finally block)
- No duplicate cleanup code
</success_criteria>

<output>
After completion, create `.planning/phases/04-edge-function-processing/04-01-SUMMARY.md`
</output>
