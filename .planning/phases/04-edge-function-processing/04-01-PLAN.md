---
phase: 04-edge-function-processing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/functions/process-embeddings/index.ts
autonomous: true

must_haves:
  truths:
    - "Edge function downloads file from storage successfully"
    - "Blob MIME type accessed correctly (fileBlob.type not .mime_type)"
    - "Gemini files are cleaned up even when function crashes"
    - "Document status updates to error with details on any failure"
  artifacts:
    - path: "supabase/functions/process-embeddings/index.ts"
      provides: "Fixed edge function with proper error handling and cleanup"
      contains: "finally"
  key_links:
    - from: "supabase/functions/process-embeddings/index.ts"
      to: "Supabase Storage"
      via: "supabase.storage.from('project-files').download()"
      pattern: "fileBlob\\.type"
    - from: "supabase/functions/process-embeddings/index.ts"
      to: "Gemini Files API"
      via: "genAI.files.delete in finally block"
      pattern: "finally.*files\\.delete"
---

<objective>
Fix critical bugs in edge function: Blob MIME type access, error handling, and Gemini file cleanup.

Purpose: The current edge function has P0 bugs that prevent chunks from being created. This plan fixes the foundational issues before implementing batch embedding improvements.

Output: Edge function that properly handles file downloads, updates document status on errors, and cleans up Gemini files in all cases.
</objective>

<execution_context>
@/Users/cweissteiner/.claude/get-shit-done/workflows/execute-plan.md
@/Users/cweissteiner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/04-edge-function-processing/04-CONTEXT.md
@.planning/research/PITFALLS.md

@supabase/functions/process-embeddings/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix Blob MIME type and request body parsing</name>
  <files>supabase/functions/process-embeddings/index.ts</files>
  <action>
Fix the MIME type and request body re-parsing bugs:

1. **Blob MIME type** (around line 77-82): Change `fileBlob.mime_type` to `fileBlob.type`. JavaScript Blob objects have `.type` property, not `.mime_type`. Add fallback to `document.mime_type` from the DB record:
```typescript
const mimeType = fileBlob.type || document.mime_type;
```

2. **Request body re-parsing**: The error handler tries to call `req.json()` again after it was already consumed at line 37. Fix by storing `documentId` immediately after parsing at the top of the try block:
```typescript
const payload = await req.json();
const documentId = payload.record.id;  // Store immediately
```

3. **Update error handling** to use the stored documentId (instead of re-parsing request):
```typescript
if (documentId) {
  await supabase
    .from("documents")
    .update({
      status: "error",
      error_details: {
        code: "PROCESSING_ERROR",
        message: error.message,
        timestamp: new Date().toISOString(),
        stage: currentStage
      }
    })
    .eq("id", documentId);
}
```
  </action>
  <verify>
- Read the modified file and confirm:
  - `fileBlob.type` is used instead of `fileBlob.mime_type`
  - `documentId` is stored before any processing
  - Error handler uses stored `documentId`, not re-parsed request
  - `error_details` JSONB is populated with code, message, timestamp, stage
  </verify>
  <done>
- Blob MIME type accessed via `.type` property with fallback
- Error handling uses pre-stored documentId
- Error details include processing stage information
  </done>
</task>

<task type="auto">
  <name>Task 2: Add stage tracking and Gemini cleanup in finally block</name>
  <files>supabase/functions/process-embeddings/index.ts</files>
  <action>
Implement stage tracking and Gemini file cleanup that happens even when the function crashes.

**Variable declarations at function start (outside try block):**

Declare these variables at the very start of the `Deno.serve` handler, BEFORE the try block begins:
```typescript
Deno.serve(async (req) => {
  // Declare at function scope - BEFORE try block
  let documentId: string | null = null;
  let uploadedFile: { file: { name: string; uri: string; mimeType: string } } | null = null;
  let currentStage = 'init';

  const supabase = createClient(...);

  try {
    // After parsing payload, ASSIGN to the outer-scoped variable:
    const payload = await req.json();
    documentId = payload.record.id;  // Assignment, not declaration

    // ... processing continues ...

    // After Gemini upload succeeds, ASSIGN to outer-scoped variable:
    uploadedFile = await genAI.files.upload({...});  // Assignment
```

**Stage tracking updates throughout processing:**

Update `currentStage` as processing progresses:
```typescript
currentStage = 'downloading';
// ... download file ...

currentStage = 'uploading_gemini';
uploadedFile = await genAI.files.upload({...});

currentStage = 'extracting_text';
// ... text extraction ...

currentStage = 'chunking';
// ... chunking ...

currentStage = 'embedding';
// ... embedding ...

currentStage = 'inserting';
// ... database insert ...
```

**Finally block for cleanup:**

Add finally block AFTER the catch block to ensure Gemini cleanup always runs:
```typescript
  } catch (error) {
    // ... error handling ...
    return new Response(...);
  } finally {
    // EDGE-03: Always cleanup Gemini files, even on error
    if (uploadedFile?.file?.name) {
      try {
        await genAI.files.delete({ name: uploadedFile.file.name });
        console.log(`Cleaned up Gemini file: ${uploadedFile.file.name}`);
      } catch (cleanupError) {
        // Log but don't throw - cleanup failure shouldn't mask original error
        console.warn(`Failed to cleanup Gemini file ${uploadedFile.file.name}:`, cleanupError);
      }
    }
  }

  return new Response(...);
});
```

**Remove duplicate cleanup code:**

Remove the existing cleanup try-catch at lines 173-178 since the finally block now handles all cleanup.
  </action>
  <verify>
- Confirm `let documentId`, `let uploadedFile`, `let currentStage` are declared BEFORE the try block
- Confirm assignments happen INSIDE the try block (not new declarations with `const`)
- Confirm `finally` block exists with Gemini file cleanup
- Confirm cleanup uses try-catch to avoid masking original errors
- Confirm old cleanup code at lines 173-178 is removed
  </verify>
  <done>
- Variables declared at function scope, assigned inside try block
- Stage tracking updates as processing progresses
- Gemini files are cleaned up in finally block (even on error)
- Cleanup failures are logged but don't throw
- Function structure follows try/catch/finally pattern
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **Code review**: Read the full edge function and verify:
   - No references to `fileBlob.mime_type` (should all be `fileBlob.type`)
   - `documentId`, `uploadedFile`, `currentStage` declared before try block
   - Assignments (not re-declarations) happen inside try block
   - `finally` block exists with Gemini cleanup
   - Error updates include `error_details` JSONB with stage information

2. **Syntax check**: The TypeScript code should be valid (no syntax errors)

3. **Pattern check**: Verify the structure follows:
```
let documentId, uploadedFile, currentStage  // declarations
try {
  documentId = ...  // assignments
  uploadedFile = ...
  currentStage = 'stage_name'
}
catch { ... error handling with documentId ... }
finally { ... Gemini cleanup using uploadedFile ... }
```
</verification>

<success_criteria>
- Blob MIME type bug fixed (uses .type not .mime_type)
- Request body not re-parsed in error handler
- Error details include processing stage
- Gemini files always cleaned up (finally block)
- No duplicate cleanup code
</success_criteria>

<output>
After completion, create `.planning/phases/04-edge-function-processing/04-01-SUMMARY.md`
</output>
