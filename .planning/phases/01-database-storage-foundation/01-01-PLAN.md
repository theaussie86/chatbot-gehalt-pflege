---
phase: 01-database-storage-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/api/migrations/20260123000000_phase1_foundation.sql
autonomous: true

must_haves:
  truths:
    - "Service role can insert into document_chunks table without RLS errors"
    - "Deleting a document automatically removes all associated chunks"
    - "Documents table has error_details JSONB column for storing structured error information"
  artifacts:
    - path: "apps/api/migrations/20260123000000_phase1_foundation.sql"
      provides: "Migration with RLS policy fix and error_details column"
      contains: "error_details JSONB"
  key_links:
    - from: "document_chunks INSERT policy"
      to: "service_role"
      via: "auth.jwt()->>'role' = 'service_role' check"
      pattern: "service_role"
    - from: "document_chunks.document_id"
      to: "documents.id"
      via: "ON DELETE CASCADE foreign key"
      pattern: "on delete cascade"
---

<objective>
Fix P0-blocking database issues that prevent the edge function from inserting chunks into document_chunks table.

Purpose: The edge function uses service role key but current RLS policies may block it. The documents table also lacks an error_details column for structured error storage. These fixes are prerequisites for all downstream document pipeline work.

Output: Single migration file containing RLS policy fix, error_details column addition, and verification that cascade delete is working.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-database-storage-foundation/01-CONTEXT.md
@.planning/phases/01-database-storage-foundation/01-RESEARCH.md

# Existing migrations to understand current schema
@apps/api/migrations/20260121000000_rls_reset.sql
@apps/api/migrations/20260115120000_init_rag_pipeline.sql
@apps/api/migrations/20260115170000_add_document_status.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Phase 1 Foundation Migration</name>
  <files>apps/api/migrations/20260123000000_phase1_foundation.sql</files>
  <action>
Create a single migration file that addresses all three DB requirements:

**1. Fix RLS policy for document_chunks INSERT (DB-02):**
The current "Admins can insert chunks" policy in 20260121000000_rls_reset.sql only targets `TO authenticated` and uses `is_global_admin()` / `has_project_role()` which call `auth.uid()`. When the edge function connects with service role key, `auth.uid()` returns NULL, causing the policy check to fail.

Solution: Drop the existing INSERT policy and create a new one that explicitly allows service role:
```sql
DROP POLICY IF EXISTS "Admins can insert chunks" ON document_chunks;

CREATE POLICY "Service role and admins can insert chunks"
  ON document_chunks FOR INSERT
  TO authenticated
  WITH CHECK (
    -- Service role always allowed (edge function)
    auth.jwt()->>'role' = 'service_role'
    OR
    -- User permission checks (existing logic)
    EXISTS (
      SELECT 1 FROM documents
      WHERE documents.id = document_chunks.document_id
      AND (
        (documents.project_id IS NULL AND is_global_admin())
        OR (documents.project_id IS NOT NULL AND has_project_role(documents.project_id, ARRAY['admin', 'editor']))
        OR is_global_admin()
      )
    )
  );
```

**2. Add error_details JSONB column (DB-03):**
Add column to documents table for structured error storage:
```sql
ALTER TABLE documents
ADD COLUMN IF NOT EXISTS error_details JSONB;

COMMENT ON COLUMN documents.error_details IS
  'Structured error information: {code: string, message: string, timestamp: string}';
```

**3. Verify cascade delete configuration (DB-01):**
The cascade is already defined in migration 20260115120000_init_rag_pipeline.sql line 59. Add a comment confirming this, but no schema change needed:
```sql
-- DB-01: Cascade delete verified - defined in 20260115120000_init_rag_pipeline.sql
-- document_chunks.document_id references documents(id) on delete cascade
```

Include a header comment explaining the migration purpose.
  </action>
  <verify>
Run: `cat apps/api/migrations/20260123000000_phase1_foundation.sql`
Confirm file contains:
- DROP POLICY for old INSERT policy
- CREATE POLICY with service_role check
- ALTER TABLE for error_details column
- Comments for DB-01 cascade verification
  </verify>
  <done>Migration file exists with all three fixes documented and ready to apply</done>
</task>

<task type="auto">
  <name>Task 2: Create Verification SQL Script</name>
  <files>apps/api/migrations/phase1_verification.sql</files>
  <action>
Create a verification script that can be run AFTER the migration is applied to confirm all fixes work. This is NOT a migration - it's a manual verification script for the admin.

The script should:

**1. Test service role INSERT (DB-02):**
```sql
-- Test: Service role can insert into document_chunks
-- Run this in SQL Editor with service role connection

-- First, find a document to test with (or create one)
-- This is a read-only verification - actual test happens in Task 3

SELECT
  current_user,
  session_user,
  auth.jwt()->>'role' as jwt_role;
-- Expected: jwt_role = 'service_role' when connected with service key
```

**2. Test cascade delete (DB-01):**
```sql
-- Test: Cascade delete works
-- Create test document and chunk, delete document, verify chunk is gone

-- Step 1: Create test document (requires project_id or NULL for global)
INSERT INTO documents (id, filename, storage_path, status, project_id)
VALUES ('00000000-0000-0000-0000-000000000001', 'cascade-test.pdf', 'test/path', 'pending', NULL)
ON CONFLICT (id) DO NOTHING
RETURNING id;

-- Step 2: Create test chunk (will fail if RLS not fixed, but that's fine for cascade test)
-- Run with service role or as admin

-- Step 3: Delete document
DELETE FROM documents WHERE id = '00000000-0000-0000-0000-000000000001';

-- Step 4: Verify chunk is gone (should return 0 rows)
SELECT count(*) as orphaned_chunks
FROM document_chunks
WHERE document_id = '00000000-0000-0000-0000-000000000001';
-- Expected: 0
```

**3. Verify error_details column (DB-03):**
```sql
-- Test: error_details column exists
SELECT column_name, data_type, is_nullable
FROM information_schema.columns
WHERE table_name = 'documents' AND column_name = 'error_details';
-- Expected: 1 row with data_type = 'jsonb'

-- Test: Can store structured error
UPDATE documents
SET error_details = '{"code": "TEST_ERROR", "message": "Test error message", "timestamp": "2026-01-23T00:00:00Z"}'::jsonb
WHERE id = (SELECT id FROM documents LIMIT 1);

-- Verify JSON structure
SELECT error_details->>'code' as code, error_details->>'message' as message
FROM documents
WHERE error_details IS NOT NULL
LIMIT 1;
```

Add clear instructions at the top explaining this is a manual verification script.
  </action>
  <verify>
Run: `cat apps/api/migrations/phase1_verification.sql`
Confirm file contains verification queries for all three requirements with expected results documented.
  </verify>
  <done>Verification script exists with tests for DB-01, DB-02, and DB-03</done>
</task>

<task type="auto">
  <name>Task 3: Verify Storage Bucket Configuration</name>
  <files>N/A - verification only</files>
  <action>
Verify the storage bucket configuration is correct by checking the existing migration and documenting findings.

**1. Check bucket creation in migrations:**
Review 20260115120000_init_rag_pipeline.sql lines 5-7 to confirm:
- Bucket 'project-files' is created
- file_size_limit is 52428800 (50MB)
- allowed_mime_types includes 'application/pdf'

**2. Check storage RLS policies:**
Review 20260121000000_rls_reset.sql lines 385-441 to confirm:
- "View files" policy allows project members and global admins
- "Upload files" policy allows project admin/editor
- "Delete files" policy allows project admin/editor

**3. Document findings:**
Create a brief note in the SUMMARY explaining:
- Bucket: Configured correctly for project-files
- Size limit: 50MB
- MIME types: PDF only (may need expansion in Phase 2 for text/spreadsheets)
- RLS: Properly configured for authenticated users

Note: The storage bucket RLS policies do NOT need service role access because the edge function downloads files using service role which bypasses storage RLS. Only document_chunks INSERT needed the fix.
  </action>
  <verify>
Read migrations and confirm bucket configuration is present:
- 20260115120000_init_rag_pipeline.sql contains bucket creation
- 20260121000000_rls_reset.sql contains storage policies
  </verify>
  <done>Storage bucket configuration verified and documented in summary</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Migration file exists:** `apps/api/migrations/20260123000000_phase1_foundation.sql`
2. **Verification script exists:** `apps/api/migrations/phase1_verification.sql`
3. **All three requirements addressed:**
   - DB-01: Cascade delete confirmed via schema inspection
   - DB-02: RLS policy fix includes service_role check
   - DB-03: error_details JSONB column added

Note: Actual migration application happens via Supabase MCP or manual SQL execution. This plan creates the files; applying them is a separate step.
</verification>

<success_criteria>
- Migration file created with all three fixes
- Verification script created with test queries
- Storage bucket configuration documented
- Files ready for application to Supabase database
</success_criteria>

<output>
After completion, create `.planning/phases/01-database-storage-foundation/01-01-SUMMARY.md` following the summary template.

Include:
- Which requirements were addressed (DB-01, DB-02, DB-03)
- Files created
- Next step: Apply migration via Supabase dashboard or CLI
- Note about storage bucket configuration
</output>
