---
phase: 06-rag-integration
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - apps/api/app/api/chat/route.ts
  - apps/api/app/actions/documents.ts
autonomous: true

must_haves:
  truths:
    - "User asks question and receives answer with document citation"
    - "Response includes source filename when documents are found"
    - "Cache is invalidated when documents are deleted"
    - "Cache is invalidated when documents are reprocessed"
    - "Questions without relevant documents get graceful fallback"
  artifacts:
    - path: "apps/api/app/api/chat/route.ts"
      provides: "RAG-augmented question handling with citations"
      contains: "queryWithMetadata"
    - path: "apps/api/app/actions/documents.ts"
      provides: "Cache invalidation on document changes"
      contains: "clearCache"
  key_links:
    - from: "apps/api/app/api/chat/route.ts"
      to: "VectorstoreService.queryWithMetadata"
      via: "vectorstore.queryWithMetadata call"
      pattern: "vectorstore\\.queryWithMetadata"
    - from: "apps/api/app/actions/documents.ts"
      to: "VectorstoreService.clearCache"
      via: "cache invalidation on delete/reprocess"
      pattern: "vectorstore\\.clearCache"
---

<objective>
Wire RAG retrieval into chat flow and add cache invalidation to document actions.

Purpose: Complete the RAG integration by (1) replacing the basic vectorstore.query() call with queryWithMetadata() and adding citation formatting to responses, and (2) ensuring the vectorstore cache is cleared when documents change so users get fresh answers.

Output: Working end-to-end RAG flow where questions get document-grounded answers with citations, and document updates trigger cache invalidation.
</objective>

<execution_context>
@/Users/cweissteiner/.claude/get-shit-done/workflows/execute-plan.md
@/Users/cweissteiner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-rag-integration/06-RESEARCH.md
@.planning/phases/06-rag-integration/06-01-SUMMARY.md

# Key source files
@apps/api/app/api/chat/route.ts
@apps/api/app/actions/documents.ts
@apps/api/lib/vectorstore/VectorstoreService.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance chat route question handling with citations</name>
  <files>apps/api/app/api/chat/route.ts</files>
  <action>
Modify the question handling block (around line 202-243) to use queryWithMetadata() instead of query() and add citation formatting.

Current code at line 202-243:
```typescript
if (nextFormState.userIntent === 'question') {
    // Query vectorstore for answer
    const vectorstoreAnswer = await vectorstore.query(message, activeProjectId);
    // ... prompt building ...
}
```

Replace with enhanced version that:
1. Call vectorstore.queryWithMetadata(message, activeProjectId, 3) instead of query()
2. Filter results by similarity >= 0.75 to avoid low-quality matches
3. Build context section with numbered citations: [Quelle 1: filename.pdf]
4. If no relevant results, add "Hinweis: Ich habe keine relevanten Informationen in den hochgeladenen Dokumenten gefunden."
5. Update the prompt to instruct Gemini to cite sources

New implementation (replace lines 202-243):
```typescript
// --- US-007: HANDLE QUESTION INTENT WITH RAG + CITATIONS ---
if (nextFormState.userIntent === 'question') {
    // Query vectorstore with metadata for citation attribution
    const ragResults = await vectorstore.queryWithMetadata(message, activeProjectId, 3);

    // Filter by similarity threshold to avoid noise
    const relevantResults = ragResults.filter(r => r.similarity >= 0.75);

    // Build context section with citations
    let contextSection = '';
    if (relevantResults.length > 0) {
        contextSection = `
Relevante Informationen aus hochgeladenen Dokumenten:

${relevantResults.map((r, i) => `
[Quelle ${i + 1}: ${r.metadata.filename}]
${r.content}
`).join('\n---\n')}
`;
    } else {
        contextSection = 'Hinweis: Ich habe keine relevanten Informationen in den hochgeladenen Dokumenten gefunden.';
    }

    const questionPrompt = `
Du bist ein freundlicher Gehalts-Chatbot fuer Pflegekraefte.
Der Nutzer hat eine Frage gestellt.

Nutzer-Frage: "${message}"

${contextSection}

Aktueller Status: Wir sind im Schritt "${nextFormState.section}".
Noch fehlende Informationen: ${nextFormState.missingFields?.join(', ') || 'keine'}

Aufgabe:
1. Beantworte die Frage kurz und praezise basierend auf den Informationen aus den Dokumenten
2. Zitiere die Quelle am Ende deiner Antwort (z.B. "Quelle: Dokument.pdf")
3. Wenn keine relevanten Informationen gefunden wurden, sage das ehrlich
4. Kehre dann sanft zum Interview zurueck und frage nach den fehlenden Daten

WICHTIG:
- Frage nicht nach technischen Begriffen wie "Entgeltgruppe" oder "Stufe"
- Frage stattdessen nach dem Beruf, der Ausbildung, den Arbeitsstunden, etc.
- Antworte NUR mit Informationen aus den bereitgestellten Quellen
- Bei Unsicherheit: "Dazu habe ich keine Informationen in meinen Dokumenten."

Fortschritt: [PROGRESS: ${SalaryStateMachine.getProgress(nextFormState)}]
    `;

    const responseResult = await client.models.generateContent({
        model: 'gemini-2.5-flash',
        contents: questionPrompt
    });
    let responseText = responseResult.text || '';

    // Add progress marker if not present
    if (!responseText.includes('[PROGRESS:')) {
        responseText += `\n\n[PROGRESS: ${SalaryStateMachine.getProgress(nextFormState)}]`;
    }

    return NextResponse.json({
        text: responseText,
        formState: nextFormState
    });
}
```

IMPORTANT:
- Keep the import for VectorstoreService at the top (already exists)
- FIX ENV VAR: The existing vectorstore initialization at lines 17-21 and 140-143 uses SUPABASE_SERVICE_KEY which does NOT exist in .env. Change ALL occurrences of SUPABASE_SERVICE_KEY to SUPABASE_SERVICE_ROLE_KEY:
  - Line 17: Change `process.env.SUPABASE_SERVICE_KEY` to `process.env.SUPABASE_SERVICE_ROLE_KEY`
  - Line 19 (error message): Change "SUPABASE_SERVICE_KEY" to "SUPABASE_SERVICE_ROLE_KEY"
  - Line 142: Change `process.env.SUPABASE_SERVICE_KEY` to `process.env.SUPABASE_SERVICE_ROLE_KEY`
- Only modify the question handling block (if nextFormState.userIntent === 'question')
- Use German umlauts as escape sequences (fuer, Pflegekraefte, praezise, zurueck) to avoid encoding issues
  </action>
  <verify>
TypeScript compiles: cd apps/api && npx tsc --noEmit
Grep for "queryWithMetadata" in chat/route.ts
Grep for "Quelle" in chat/route.ts (citation formatting)
Grep for "SUPABASE_SERVICE_ROLE_KEY" in chat/route.ts (3 occurrences expected)
  </verify>
  <done>
Chat route uses queryWithMetadata() for question handling, includes citation formatting with source filenames, and uses correct SUPABASE_SERVICE_ROLE_KEY environment variable.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add cache invalidation to document actions</name>
  <files>apps/api/app/actions/documents.ts</files>
  <action>
Add VectorstoreService import and cache invalidation calls to deleteDocumentAction, bulkDeleteDocumentsAction, and reprocessDocumentAction.

1. Add import at top of file (after existing imports around line 5):
```typescript
import { VectorstoreService } from "@/lib/vectorstore/VectorstoreService";
```

2. Create a helper function to get vectorstore instance (add after imports):
```typescript
function getVectorstoreForCacheInvalidation(): VectorstoreService | null {
    const url = process.env.NEXT_PUBLIC_SUPABASE_URL;
    const key = process.env.SUPABASE_SERVICE_ROLE_KEY;
    if (!url || !key) {
        console.warn('[RAG] Missing env vars for cache invalidation');
        return null;
    }
    return new VectorstoreService(url, key);
}
```

3. In deleteDocumentAction (around line 53-67), add cache invalidation AFTER successful delete:
After line 60 (await deleteDocumentService(documentId, user.id)):
```typescript
// Invalidate RAG cache after document deletion
const vectorstore = getVectorstoreForCacheInvalidation();
if (vectorstore) {
    vectorstore.clearCache();
    console.log('[RAG] Cache invalidated after document deletion');
}
```

4. In reprocessDocumentAction (around line 164-217), add cache invalidation AFTER successful status update:
After line 210 (if (error) throw error):
```typescript
// Invalidate RAG cache after reprocess to clear stale answers
const vectorstore = getVectorstoreForCacheInvalidation();
if (vectorstore) {
    vectorstore.clearCache();
    console.log('[RAG] Cache invalidated after document reprocess');
}
```

5. In bulkDeleteDocumentsAction (around line 219-289), add cache invalidation AFTER the loop completes (before revalidatePath calls):
After line 275 (closing brace of for loop), before line 277 (const successCount):
```typescript
// Invalidate RAG cache after bulk delete
if (results.some(r => r.success)) {
    const vectorstore = getVectorstoreForCacheInvalidation();
    if (vectorstore) {
        vectorstore.clearCache();
        console.log('[RAG] Cache invalidated after bulk delete');
    }
}
```

IMPORTANT:
- Do NOT modify uploadDocumentAction (cache doesn't need clearing on upload - new embeddings will be fetched naturally)
- Do NOT modify createDocumentRecordAction (same reason)
- Do NOT modify getDocumentDownloadUrlAction (no document change)
- The clearCache() call is simple and fast - it just clears an in-memory Map
  </action>
  <verify>
TypeScript compiles: cd apps/api && npx tsc --noEmit
Grep for "VectorstoreService" in documents.ts
Grep for "clearCache" in documents.ts
  </verify>
  <done>
Document actions (delete, bulkDelete, reprocess) invalidate VectorstoreService cache after successful operations.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete RAG integration: chat route uses queryWithMetadata() for questions with citation formatting, and document actions invalidate cache on changes.
  </what-built>
  <how-to-verify>
1. **Apply migration (required for new RPC function):**
   - Run in Supabase SQL Editor: contents of `apps/api/migrations/20260125000000_match_documents_with_metadata.sql`

2. **Deploy edge function if not already deployed:**
   ```bash
   supabase functions deploy process-embeddings --project-ref xjbkpfbiajcjkamvlrhw
   ```

3. **Start dev server:**
   ```bash
   cd apps/api && npm run dev
   ```

4. **Test RAG flow:**
   - Upload a document about nursing tariffs (e.g., a PDF with TVoeD salary tables)
   - Wait for status to change to "embedded" (check admin documents page)
   - Open chatbot widget
   - Ask a question about tariffs: "Was ist das Gehalt fuer eine Pflegefachkraft in Stufe 3?"
   - Expected: Response includes information from the document AND cites the source (e.g., "Quelle: tarif-tabelle.pdf")

5. **Test cache invalidation:**
   - Delete the uploaded document
   - Ask the same question again
   - Expected: Response should NOT include the deleted document's information

6. **Test no-results case:**
   - Ask an unrelated question: "Was kostet ein iPhone?"
   - Expected: Response says "Dazu habe ich keine Informationen in meinen Dokumenten" or similar
  </how-to-verify>
  <resume-signal>Type "approved" if RAG flow works with citations, or describe issues</resume-signal>
</task>

</tasks>

<verification>
1. Chat route uses vectorstore.queryWithMetadata() instead of query()
2. Responses include citation with filename when documents are found
3. Cache invalidation added to delete, bulkDelete, and reprocess actions
4. TypeScript compiles without errors
5. Human verifies E2E flow: upload doc -> ask question -> see cited answer
</verification>

<success_criteria>
- [ ] queryWithMetadata() called in chat route question handling
- [ ] Responses include "Quelle: [filename]" citation format
- [ ] Similarity threshold 0.75 filters low-quality matches
- [ ] deleteDocumentAction calls vectorstore.clearCache()
- [ ] bulkDeleteDocumentsAction calls vectorstore.clearCache()
- [ ] reprocessDocumentAction calls vectorstore.clearCache()
- [ ] TypeScript compiles without errors
- [ ] Human verifies: question gets document-grounded answer with citation
</success_criteria>

<output>
After completion, create `.planning/phases/06-rag-integration/06-02-SUMMARY.md`
</output>
