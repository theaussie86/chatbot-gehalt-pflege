---
phase: 06-rag-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/api/lib/vectorstore/VectorstoreService.ts
  - supabase/migrations/20260125000000_match_documents_with_metadata.sql
autonomous: true

must_haves:
  truths:
    - "VectorstoreService.queryWithMetadata() returns chunks with filename"
    - "SQL function match_documents_with_metadata exists and returns document metadata"
    - "Only embedded documents are searched (status = 'embedded')"
  artifacts:
    - path: "apps/api/lib/vectorstore/VectorstoreService.ts"
      provides: "queryWithMetadata method"
      contains: "queryWithMetadata"
    - path: "supabase/migrations/20260125000000_match_documents_with_metadata.sql"
      provides: "Enhanced search function with filename JOIN"
      contains: "match_documents_with_metadata"
  key_links:
    - from: "VectorstoreService.queryWithMetadata"
      to: "match_documents_with_metadata RPC"
      via: "supabase.rpc call"
      pattern: "supabase\\.rpc\\(['\"]match_documents_with_metadata"
---

<objective>
Add metadata-aware semantic search to enable citation attribution in RAG responses.

Purpose: The chatbot needs to cite which document provided an answer. This requires the VectorstoreService to return not just chunk content, but also the source document filename and ID. The existing match_documents function only returns content; we need an enhanced version that JOINs with the documents table.

Output: Enhanced VectorstoreService with queryWithMetadata() method and supporting SQL function.
</objective>

<execution_context>
@/Users/cweissteiner/.claude/get-shit-done/workflows/execute-plan.md
@/Users/cweissteiner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-rag-integration/06-RESEARCH.md

# Key source files
@apps/api/lib/vectorstore/VectorstoreService.ts
@apps/api/migrations/20260115120000_init_rag_pipeline.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SQL function for metadata-aware search</name>
  <files>supabase/migrations/20260125000000_match_documents_with_metadata.sql</files>
  <action>
Create a new SQL migration file that defines match_documents_with_metadata function.

The function must:
1. Accept same parameters as existing match_documents: query_embedding vector(768), match_threshold float, match_count int, filter_project_id uuid
2. Return TABLE with: id uuid, content text, similarity float, document_id uuid, filename text, chunk_index integer
3. JOIN document_chunks with documents table to get filename
4. Filter by project_id matching filter_project_id
5. Filter by documents.status = 'embedded' (only search successfully processed documents)
6. Order by cosine similarity (embedding <=> query_embedding)
7. Use LANGUAGE plpgsql (consistent with existing function)

Use this template:
```sql
CREATE OR REPLACE FUNCTION match_documents_with_metadata(
  query_embedding vector(768),
  match_threshold float,
  match_count int,
  filter_project_id uuid
)
RETURNS TABLE (
  id uuid,
  content text,
  similarity float,
  document_id uuid,
  filename text,
  chunk_index integer
)
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  SELECT
    dc.id,
    dc.content,
    1 - (dc.embedding <=> query_embedding) as similarity,
    dc.document_id,
    d.filename,
    dc.chunk_index
  FROM document_chunks dc
  JOIN documents d ON d.id = dc.document_id
  WHERE 1 - (dc.embedding <=> query_embedding) > match_threshold
    AND d.project_id = filter_project_id
    AND d.status = 'embedded'
  ORDER BY dc.embedding <=> query_embedding
  LIMIT match_count;
END;
$$;
```

IMPORTANT: Do NOT modify the existing match_documents function. Create a NEW function alongside it.
  </action>
  <verify>
File exists at supabase/migrations/20260125000000_match_documents_with_metadata.sql with correct CREATE OR REPLACE FUNCTION syntax.
Grep for "match_documents_with_metadata" and "d.status = 'embedded'" in the file.
  </verify>
  <done>
Migration file created with match_documents_with_metadata function that JOINs document_chunks with documents to return filename and filters by embedded status.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add queryWithMetadata method to VectorstoreService</name>
  <files>apps/api/lib/vectorstore/VectorstoreService.ts</files>
  <action>
Add a new method queryWithMetadata() to VectorstoreService class, placed after the existing query() method.

The method signature:
```typescript
async queryWithMetadata(
    question: string,
    projectId: string,
    topK = 3
): Promise<Array<{
    content: string;
    similarity: number;
    metadata: {
        documentId: string;
        filename: string;
        chunkIndex: number;
    }
}>>
```

Implementation:
1. Generate embedding for question using this.generateEmbedding(question)
2. Call supabase.rpc('match_documents_with_metadata', { query_embedding, match_threshold: 0.7, match_count: topK, filter_project_id: projectId })
3. Handle error case: log error and return empty array
4. Handle empty results: return empty array
5. Map results to the return type, extracting document_id, filename, chunk_index into metadata object

Add JSDoc comment explaining the method's purpose for citation attribution.

Do NOT modify the existing query() method or clearCache() method.

Example implementation structure (place after query() method around line 208):
```typescript
/**
 * Query vectorstore with full metadata for citation attribution
 * @param question The user's question
 * @param projectId The project ID for filtering
 * @param topK Number of top results to return (default: 3)
 * @returns Array of results with content, similarity score, and metadata for citations
 */
async queryWithMetadata(
    question: string,
    projectId: string,
    topK = 3
): Promise<Array<{
    content: string;
    similarity: number;
    metadata: {
        documentId: string;
        filename: string;
        chunkIndex: number;
    }
}>> {
    try {
        // 1. Generate embedding for question
        const embedding = await this.generateEmbedding(question);

        // 2. Semantic search with metadata join
        const { data: results, error } = await this.supabase.rpc('match_documents_with_metadata', {
            query_embedding: embedding,
            match_threshold: 0.7,
            match_count: topK,
            filter_project_id: projectId
        });

        if (error) {
            console.error('[VectorstoreService] Metadata search error:', error);
            return [];
        }

        if (!results || results.length === 0) {
            return [];
        }

        // 3. Format results with metadata
        return results.map((r: any) => ({
            content: r.content,
            similarity: r.similarity,
            metadata: {
                documentId: r.document_id,
                filename: r.filename,
                chunkIndex: r.chunk_index
            }
        }));

    } catch (error) {
        console.error('[VectorstoreService] Query with metadata failed:', error);
        return [];
    }
}
```
  </action>
  <verify>
TypeScript compiles without errors: cd apps/api && npx tsc --noEmit
Grep for "queryWithMetadata" in VectorstoreService.ts
  </verify>
  <done>
VectorstoreService has queryWithMetadata() method that returns chunks with content, similarity, and metadata (documentId, filename, chunkIndex).
  </done>
</task>

</tasks>

<verification>
1. SQL migration file exists with match_documents_with_metadata function
2. VectorstoreService.ts has queryWithMetadata method
3. TypeScript compiles: `cd apps/api && npx tsc --noEmit`
4. Method returns proper type: Array<{ content, similarity, metadata: { documentId, filename, chunkIndex } }>
</verification>

<success_criteria>
- [ ] Migration file supabase/migrations/20260125000000_match_documents_with_metadata.sql created
- [ ] SQL function JOINs document_chunks with documents table
- [ ] SQL function filters by status = 'embedded'
- [ ] queryWithMetadata() method added to VectorstoreService
- [ ] Method returns metadata with filename for citation
- [ ] TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-rag-integration/06-01-SUMMARY.md`
</output>
