---
phase: 02-atomic-file-operations
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/api/utils/documents.ts
  - apps/api/app/actions/documents.ts
  - apps/api/components/DocumentManager.tsx
autonomous: true

must_haves:
  truths:
    - "Admin clicks document name and PDF opens in new tab"
    - "Admin clicks download icon and file downloads directly"
    - "Signed URLs expire after 5 minutes"
    - "Expired link shows error with refresh option"
    - "Delete confirmation modal shows document name"
    - "Delete removes both storage file and database record"
    - "Delete failure leaves both storage and DB in consistent state"
  artifacts:
    - path: "apps/api/utils/documents.ts"
      provides: "Atomic delete service with DB-first pattern"
      contains: "deleteDocumentService"
    - path: "apps/api/app/actions/documents.ts"
      provides: "Download action with 5-minute signed URLs"
      contains: "300"
  key_links:
    - from: "apps/api/components/DocumentManager.tsx"
      to: "apps/api/app/actions/documents.ts"
      via: "deleteDocumentAction call"
      pattern: "deleteDocumentAction"
    - from: "apps/api/components/DocumentManager.tsx"
      to: "apps/api/app/actions/documents.ts"
      via: "getDocumentDownloadUrlAction call"
      pattern: "getDocumentDownloadUrlAction"
---

<objective>
Implement atomic delete with compensating transactions and enhance download with 5-minute signed URLs.

Purpose: Deliver FILE-02 (atomic delete), FILE-03 (download), and ERR-03 (delete atomicity) requirements. The current delete operation deletes storage first, then DB, which can leave orphaned DB records if storage delete succeeds but DB fails.

Output: Delete service that uses DB-first pattern with storage rollback, download actions that generate 5-minute signed URLs with refresh on expiry.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-atomic-file-operations/02-CONTEXT.md

@apps/api/utils/documents.ts
@apps/api/app/actions/documents.ts
@apps/api/components/DocumentManager.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Reorder delete operations for atomicity (DB-first)</name>
  <files>apps/api/utils/documents.ts</files>
  <action>
Modify deleteDocumentService in apps/api/utils/documents.ts to use DB-first pattern:

Current flow (problematic):
1. Fetch document
2. Delete from storage
3. Delete from DB <-- if this fails, orphaned storage deletion

New flow (atomic):
1. Fetch document (including storage_path)
2. Store storage_path in variable
3. Delete from DB FIRST
4. If DB delete succeeds, delete from storage
5. If storage delete fails AFTER DB delete, this is acceptable (orphaned file can be cleaned later, but no orphaned DB record)

Implementation:
```typescript
export async function deleteDocumentService(documentId: string, userId: string) {
    const supabase = await createClient();

    // 1. Fetch document
    const { data: document, error: fetchError } = await supabase
        .from("documents")
        .select("id, storage_path")
        .eq("id", documentId)
        .single();

    if (fetchError || !document) {
        throw new Error("Document not found");
    }

    const storagePath = document.storage_path;

    // 2. Delete from DB FIRST (cascade deletes chunks via FK)
    const { error: deleteError, count } = await supabase
        .from("documents")
        .delete({ count: 'exact' })
        .eq("id", documentId);

    if (deleteError) {
        throw new Error(`Database error: ${deleteError.message}`);
    }

    if (count === 0) {
        throw new Error("Failed to delete document: Permission denied or not found");
    }

    // 3. Delete from Storage AFTER DB success
    // If this fails, we have orphaned storage file (acceptable - can clean up later)
    // But we do NOT have orphaned DB record (critical - avoided)
    if (storagePath) {
        try {
            const { error: storageError } = await supabase.storage
                .from('project-files')
                .remove([storagePath]);

            if (storageError) {
                console.warn(`Storage cleanup failed for ${storagePath}: ${storageError.message}`);
                // Log but don't throw - DB record is already deleted
            }
        } catch (e) {
            console.warn(`Storage cleanup exception for ${storagePath}:`, e);
            // Log but don't throw
        }
    }

    return true;
}
```

Key principle: Orphaned storage files are recoverable (can run cleanup job). Orphaned DB records pointing to deleted files cause user-facing errors.
  </action>
  <verify>
1. Create a test document via upload
2. Note the storage_path in Supabase DB
3. Delete the document
4. Verify: document_chunks CASCADE deleted (via DB query)
5. Verify: storage file removed (via Supabase Storage dashboard)
  </verify>
  <done>
- Delete removes DB record before storage file
- Cascade delete removes associated chunks
- Storage failure after DB delete is logged but doesn't cause user error
  </done>
</task>

<task type="auto">
  <name>Task 2: Update download signed URL to 5 minutes with expiry handling</name>
  <files>apps/api/app/actions/documents.ts</files>
  <action>
Modify getDocumentDownloadUrlAction in apps/api/app/actions/documents.ts:

1. Change signed URL expiry from 3600 (1 hour) to 300 (5 minutes):
```typescript
const { data, error } = await supabase.storage
    .from('project-files')
    .createSignedUrl(document.storage_path, 300); // 5 minutes
```

2. Add expiry timestamp to response for client-side handling:
```typescript
return {
    url: data.signedUrl,
    expiresAt: Date.now() + 300 * 1000 // 5 minutes from now
};
```

3. Update return type to include expiresAt:
```typescript
// Return type: { url: string, expiresAt: number } | { error: string }
```
  </action>
  <verify>
1. Upload a document
2. Call getDocumentDownloadUrlAction
3. Verify URL works immediately
4. Wait 6 minutes (or change expiry to 10 seconds for testing)
5. Verify URL returns 400 Bad Request
  </verify>
  <done>
- Signed URLs expire after 5 minutes (300 seconds)
- Response includes expiresAt timestamp for client-side refresh logic
  </done>
</task>

<task type="auto">
  <name>Task 3: Enhance UI for download and delete confirmation</name>
  <files>apps/api/components/DocumentManager.tsx</files>
  <action>
Update DocumentManager.tsx to match CONTEXT.md decisions:

1. Split document name click and download icon:
   - Document name click: Opens in new tab (for inline PDF viewing)
   - Download icon button: Triggers direct download

```typescript
// In the document list item:
<button
  onClick={() => handleView(doc)}
  className="font-medium text-gray-900 dark:text-gray-200 hover:text-blue-600 hover:underline"
>
  {doc.filename}
</button>
// ... existing status badge ...
<button
  onClick={() => handleDownload(doc)}
  className="text-gray-400 hover:text-blue-600 p-1"
  title="Download file"
>
  <DownloadIcon className="w-5 h-5" />
</button>
```

2. Add handleView function that opens in new tab:
```typescript
const handleView = async (doc: Document) => {
  const result = await getDocumentDownloadUrlAction(doc.id);
  if (result.url) {
    window.open(result.url, '_blank');
  } else {
    toast.error(result.error || "Failed to get URL");
  }
};
```

3. Modify handleDownload to trigger direct download:
```typescript
const handleDownload = async (doc: Document) => {
  const result = await getDocumentDownloadUrlAction(doc.id);
  if (result.url) {
    // Create temporary link and trigger download
    const link = document.createElement('a');
    link.href = result.url;
    link.download = doc.filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  } else {
    toast.error(result.error || "Failed to get download URL");
  }
};
```

4. Handle expired links with refresh option:
```typescript
// Track URL cache with expiry
const [urlCache, setUrlCache] = useState<Map<string, { url: string, expiresAt: number }>>(new Map());

const handleView = async (doc: Document) => {
  const cached = urlCache.get(doc.id);
  if (cached && cached.expiresAt > Date.now()) {
    window.open(cached.url, '_blank');
    return;
  }

  const result = await getDocumentDownloadUrlAction(doc.id);
  if (result.url) {
    setUrlCache(prev => new Map(prev).set(doc.id, { url: result.url, expiresAt: result.expiresAt }));
    window.open(result.url, '_blank');
  } else if (result.error?.includes('expired')) {
    toast.error('Link expired. Click to generate new link.', {
      action: { label: 'Refresh', onClick: () => handleView(doc) }
    });
  } else {
    toast.error(result.error || "Failed to get URL");
  }
};
```

5. Update delete confirmation modal to show document name:
```typescript
// In AlertDialogDescription for delete:
<AlertDialogDescription>
  Delete "{documents.find(d => d.id === confirmState.documentId)?.filename}"?
  This will remove the file and all embeddings. This action cannot be undone.
</AlertDialogDescription>
```

6. Add download icon (either from Radix icons or inline SVG):
```typescript
// SVG for download icon
const DownloadIcon = ({ className }: { className?: string }) => (
  <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2}
      d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
  </svg>
);
```
  </action>
  <verify>
1. Navigate to /documents with at least one uploaded document
2. Click document name - verify PDF opens in new tab
3. Click download icon - verify file downloads with original filename
4. Delete a document - verify modal shows "Delete 'filename.pdf'?"
5. Confirm delete - verify toast shows success
  </verify>
  <done>
- Document name click opens file in new tab
- Download icon triggers direct download
- Delete modal shows document name and mentions embeddings removal
- Expired links show toast with refresh option
  </done>
</task>

</tasks>

<verification>
1. Delete atomicity:
   - Upload document, note storage_path and document ID
   - Verify document_chunks exist (if processed)
   - Delete document
   - Query DB: SELECT * FROM documents WHERE id = 'xxx' (should return 0)
   - Query DB: SELECT * FROM document_chunks WHERE document_id = 'xxx' (should return 0)
   - Check storage: file should be removed

2. Download:
   - Click document name - opens in new tab
   - Click download icon - file downloads
   - Wait 5+ minutes, click again - toast shows "expired" with refresh

3. Delete confirmation:
   - Click delete on "Tariftabelle_2025.pdf"
   - Modal shows: Delete "Tariftabelle_2025.pdf"? This will remove the file and all embeddings.
</verification>

<success_criteria>
- FILE-02 complete: Delete removes storage + DB + chunks atomically
- FILE-03 complete: Download via 5-minute signed URLs with expiry handling
- ERR-03 complete: Delete uses DB-first pattern preventing orphaned DB records
- Delete confirmation shows document name per CONTEXT.md
- View vs download behavior differentiated per CONTEXT.md
</success_criteria>

<output>
After completion, create `.planning/phases/02-atomic-file-operations/02-02-SUMMARY.md`
</output>
