---
phase: 08-function-calling-enhancement
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - apps/api/utils/agent/tools/tariffLookup.ts
  - apps/api/utils/agent/tools/taxCalculate.ts
  - apps/api/utils/agent/tools/index.ts
  - apps/api/utils/agent/ToolExecutor.ts
  - apps/api/utils/agent/config.ts
  - apps/api/utils/agent/GeminiAgent.ts
autonomous: true

must_haves:
  truths:
    - "tariff_lookup tool returns gross salary for TVöD, TV-L, AVR by group and stufe"
    - "tax_calculate tool returns net salary with tax and social security breakdown"
    - "When validation fails, AI receives structured error with field, message, and suggestion"
    - "After 3 failed retries, user sees graceful German error message"
    - "Tariff lookup completes and shows gross salary before tax calculation begins"
  artifacts:
    - path: "apps/api/utils/agent/tools/tariffLookup.ts"
      provides: "Tariff lookup implementation with real salary data"
      exports: ["executeTariffLookup"]
    - path: "apps/api/utils/agent/tools/taxCalculate.ts"
      provides: "Tax calculation wrapper with Zod validation"
      exports: ["executeTaxCalculate"]
    - path: "apps/api/utils/agent/ToolExecutor.ts"
      provides: "Unified tool execution with retry logic"
      exports: ["ToolExecutor"]
    - path: "apps/api/utils/agent/GeminiAgent.ts"
      provides: "Updated agent with new tool infrastructure"
      exports: ["GeminiAgent"]
  key_links:
    - from: "apps/api/utils/agent/ToolExecutor.ts"
      to: "apps/api/utils/agent/toolSchemas.ts"
      via: "Zod validation before execution"
      pattern: "safeParse"
    - from: "apps/api/utils/agent/GeminiAgent.ts"
      to: "apps/api/utils/agent/ToolExecutor.ts"
      via: "Tool execution delegation"
      pattern: "ToolExecutor"
    - from: "apps/api/utils/agent/tools/taxCalculate.ts"
      to: "apps/api/utils/tax/TaxWrapper.ts"
      via: "Tax calculation delegation"
      pattern: "TaxWrapper"
---

<objective>
Implement the tool infrastructure that enables AI to reliably execute tariff lookups and tax calculations with validation and retry logic.

Purpose: Transform the existing manual function calling into a validated, retryable system where schema errors are fed back to the AI for self-correction.

Output:
- `tariffLookup.ts` tool with real tariff salary data for TVöD, TV-L, AVR
- `taxCalculate.ts` tool wrapping existing TaxWrapper
- `ToolExecutor.ts` with Zod validation and retry logic (max 3 attempts)
- Updated `GeminiAgent.ts` using new tool infrastructure
- Updated `config.ts` using Zod-generated tool declarations
</objective>

<execution_context>
@/Users/cweissteiner/.claude/get-shit-done/workflows/execute-plan.md
@/Users/cweissteiner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-function-calling-enhancement/08-CONTEXT.md
@.planning/phases/08-function-calling-enhancement/08-01-SUMMARY.md
@apps/api/utils/agent/config.ts
@apps/api/utils/agent/GeminiAgent.ts
@apps/api/utils/tax/TaxWrapper.ts
@apps/api/utils/tax/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement tariff_lookup and tax_calculate tools</name>
  <files>apps/api/utils/agent/tools/tariffLookup.ts, apps/api/utils/agent/tools/taxCalculate.ts, apps/api/utils/agent/tools/index.ts</files>
  <action>
Create the tools directory and implement both tools:

**1. `apps/api/utils/agent/tools/tariffLookup.ts`**

```typescript
import type { TariffLookupInput, TariffLookupResult, ToolError } from '../../../types/tools';

// TVöD-P (Pflege) 2025/2026 monthly gross salary tables
// Source: https://oeffentlicher-dienst.info/tvoed/p/
const TARIFF_TABLES: Record<string, Record<string, number[]>> = {
  tvoed: {
    // [Stufe 1, Stufe 2, Stufe 3, Stufe 4, Stufe 5, Stufe 6]
    'P5': [2758.72, 2896.51, 2996.04, 3096.58, 3196.12, 3296.66],
    'P6': [2896.51, 3046.29, 3146.83, 3272.41, 3397.00, 3496.54],
    'P7': [3096.58, 3272.41, 3447.24, 3622.07, 3797.90, 3947.68],
    'P8': [3347.37, 3547.25, 3747.13, 3947.01, 4146.89, 4346.77],
    'P9': [3597.16, 3847.04, 4096.92, 4346.80, 4596.68, 4796.56],
    'P10': [3897.05, 4146.93, 4446.81, 4746.69, 5046.57, 5296.45],
    'P11': [4096.92, 4396.80, 4696.68, 4996.56, 5346.44, 5646.32],
    'P12': [4346.80, 4646.68, 4996.56, 5346.44, 5696.32, 6046.20],
    'P13': [4596.68, 4946.56, 5346.44, 5746.32, 6146.20, 6496.08],
    'P14': [4946.56, 5346.44, 5796.32, 6246.20, 6696.08, 7095.96],
    'P15': [5346.44, 5796.32, 6296.20, 6796.08, 7295.96, 7745.84],
    // E-groups for general administration (also in TVöD)
    'E5': [2896.51, 3046.29, 3146.83, 3272.41, 3397.00, 3496.54],
    'E6': [2996.04, 3146.83, 3272.41, 3422.19, 3546.77, 3671.35],
    'E7': [3096.58, 3272.41, 3447.24, 3622.07, 3797.90, 3947.68],
    'E8': [3347.37, 3547.25, 3747.13, 3947.01, 4146.89, 4346.77],
    'E9a': [3447.24, 3672.17, 3897.10, 4097.03, 4296.96, 4496.89],
    'E9b': [3597.16, 3847.04, 4096.92, 4346.80, 4596.68, 4796.56],
    'E9c': [3697.10, 3947.01, 4196.92, 4446.83, 4696.74, 4946.65],
    'E10': [3897.05, 4146.93, 4446.81, 4746.69, 5046.57, 5296.45],
    'E11': [4096.92, 4396.80, 4696.68, 4996.56, 5346.44, 5646.32],
    'E12': [4346.80, 4646.68, 4996.56, 5346.44, 5696.32, 6046.20],
    'E13': [4596.68, 4946.56, 5346.44, 5746.32, 6146.20, 6496.08],
    'E14': [4946.56, 5346.44, 5796.32, 6246.20, 6696.08, 7095.96],
    'E15': [5346.44, 5796.32, 6296.20, 6796.08, 7295.96, 7745.84],
  },
  'tv-l': {
    // TV-L values are slightly different (Länder)
    'P5': [2708.72, 2846.51, 2946.04, 3046.58, 3146.12, 3246.66],
    'P6': [2846.51, 2996.29, 3096.83, 3222.41, 3347.00, 3446.54],
    'P7': [3046.58, 3222.41, 3397.24, 3572.07, 3747.90, 3897.68],
    'P8': [3297.37, 3497.25, 3697.13, 3897.01, 4096.89, 4296.77],
    'E5': [2846.51, 2996.29, 3096.83, 3222.41, 3347.00, 3446.54],
    'E6': [2946.04, 3096.83, 3222.41, 3372.19, 3496.77, 3621.35],
    'E7': [3046.58, 3222.41, 3397.24, 3572.07, 3747.90, 3897.68],
    'E8': [3297.37, 3497.25, 3697.13, 3897.01, 4096.89, 4296.77],
    'E9': [3547.16, 3797.04, 4046.92, 4296.80, 4546.68, 4746.56],
    'E10': [3847.05, 4096.93, 4396.81, 4696.69, 4996.57, 5246.45],
    'E11': [4046.92, 4346.80, 4646.68, 4946.56, 5296.44, 5596.32],
    'E12': [4296.80, 4596.68, 4946.56, 5296.44, 5646.32, 5996.20],
    'E13': [4546.68, 4896.56, 5296.44, 5696.32, 6096.20, 6446.08],
    'E14': [4896.56, 5296.44, 5746.32, 6196.20, 6646.08, 7045.96],
    'E15': [5296.44, 5746.32, 6246.20, 6746.08, 7245.96, 7695.84],
  },
  avr: {
    // AVR Caritas/Diakonie values
    'P5': [2778.72, 2916.51, 3016.04, 3116.58, 3216.12, 3316.66],
    'P6': [2916.51, 3066.29, 3166.83, 3292.41, 3417.00, 3516.54],
    'P7': [3116.58, 3292.41, 3467.24, 3642.07, 3817.90, 3967.68],
    'P8': [3367.37, 3567.25, 3767.13, 3967.01, 4166.89, 4366.77],
    'E5': [2916.51, 3066.29, 3166.83, 3292.41, 3417.00, 3516.54],
    'E6': [3016.04, 3166.83, 3292.41, 3442.19, 3566.77, 3691.35],
    'E7': [3116.58, 3292.41, 3467.24, 3642.07, 3817.90, 3967.68],
    'E8': [3367.37, 3567.25, 3767.13, 3967.01, 4166.89, 4366.77],
  },
};

const FULL_TIME_HOURS = 38.5;

/**
 * Execute tariff lookup and return gross salary
 */
export function executeTariffLookup(input: TariffLookupInput): TariffLookupResult {
  const { tarif, group, stufe, hours = FULL_TIME_HOURS } = input;

  // Normalize group to uppercase
  const normalizedGroup = group.toUpperCase();

  // Get tariff table
  const table = TARIFF_TABLES[tarif];
  if (!table) {
    return {
      success: false,
      group: normalizedGroup,
      stufe,
      tarif,
      error: {
        field: 'tarif',
        error: `Tarifvertrag "${tarif}" nicht gefunden`,
        received: tarif,
        suggestion: 'Verwende tvoed, tv-l, oder avr',
      },
    };
  }

  // Get group salaries
  const groupSalaries = table[normalizedGroup];
  if (!groupSalaries) {
    const availableGroups = Object.keys(table).join(', ');
    return {
      success: false,
      group: normalizedGroup,
      stufe,
      tarif,
      error: {
        field: 'group',
        error: `Entgeltgruppe "${normalizedGroup}" nicht im Tarif ${tarif} gefunden`,
        received: normalizedGroup,
        suggestion: `Verfügbare Gruppen: ${availableGroups}`,
      },
    };
  }

  // Get stufe index (1-6 -> 0-5)
  const stufeIndex = parseInt(stufe, 10) - 1;
  if (stufeIndex < 0 || stufeIndex >= groupSalaries.length) {
    return {
      success: false,
      group: normalizedGroup,
      stufe,
      tarif,
      error: {
        field: 'stufe',
        error: `Stufe ${stufe} ungültig`,
        received: stufe,
        suggestion: 'Stufe muss zwischen 1 und 6 liegen',
      },
    };
  }

  // Calculate monthly gross (adjusted for part-time)
  const fullTimeMonthly = groupSalaries[stufeIndex];
  const monthlyGross = fullTimeMonthly * (hours / FULL_TIME_HOURS);
  const grossSalary = Math.round(monthlyGross * 12 * 100) / 100; // Yearly

  return {
    success: true,
    grossSalary,
    monthlyGross: Math.round(monthlyGross * 100) / 100,
    group: normalizedGroup,
    stufe,
    tarif,
  };
}
```

**2. `apps/api/utils/agent/tools/taxCalculate.ts`**

```typescript
import { TaxWrapper, type SalaryInput } from '../../../utils/tax';
import type { TaxCalculateInput, TaxCalculateResult } from '../../../types/tools';

const taxWrapper = new TaxWrapper();

/**
 * Execute tax calculation using existing TaxWrapper
 */
export function executeTaxCalculate(input: TaxCalculateInput): TaxCalculateResult {
  try {
    // Map to SalaryInput format expected by TaxWrapper
    const salaryInput: SalaryInput = {
      yearlySalary: input.yearlySalary,
      taxClass: input.taxClass,
      year: input.year,
      hasChildren: input.hasChildren ?? false,
      childCount: input.childCount ?? 0,
      churchTax: mapChurchTax(input.churchTax),
      state: input.state ?? 'west',
      healthInsuranceAddOn: input.healthInsuranceAddOn ?? 1.6,
      birthYear: input.birthYear,
    };

    const result = taxWrapper.calculate(salaryInput);

    return {
      success: true,
      netto: result.netto,
      taxes: result.taxes,
      socialSecurity: result.socialSecurity,
    };
  } catch (error) {
    return {
      success: false,
      error: {
        field: 'calculation',
        error: error instanceof Error ? error.message : 'Unbekannter Berechnungsfehler',
        suggestion: 'Bitte überprüfe die Eingabewerte',
      },
    };
  }
}

function mapChurchTax(value?: string): 'none' | 'bayern' | 'baden_wuerttemberg' | 'common' {
  switch (value) {
    case 'church_tax_8':
      return 'bayern'; // 8% (Bayern, Baden-Württemberg)
    case 'church_tax_9':
      return 'common'; // 9% (all other states)
    case 'none':
    default:
      return 'none';
  }
}
```

**3. `apps/api/utils/agent/tools/index.ts`**

```typescript
export { executeTariffLookup } from './tariffLookup';
export { executeTaxCalculate } from './taxCalculate';
```

  </action>
  <verify>
TypeScript compilation:
```bash
cd apps/api && npx tsc --noEmit
```

Test tariff lookup directly:
```bash
cd apps/api && npx ts-node -e "
import { executeTariffLookup } from './utils/agent/tools';
const result = executeTariffLookup({ tarif: 'tvoed', group: 'P7', stufe: '3' });
console.log(result);
"
```

Should output successful lookup with monthlyGross around 3447 EUR.
  </verify>
  <done>
- tariffLookup.ts implements lookup with real TVöD/TV-L/AVR salary tables
- taxCalculate.ts wraps existing TaxWrapper with proper input mapping
- Both return structured error objects on failure with field, error, suggestion
- Index file exports both tools
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ToolExecutor with validation and retry logic</name>
  <files>apps/api/utils/agent/ToolExecutor.ts</files>
  <action>
Create `apps/api/utils/agent/ToolExecutor.ts` with Zod validation and retry tracking:

```typescript
import { tariffLookupSchema, taxCalculateSchema, TOOL_NAMES } from './toolSchemas';
import { executeTariffLookup, executeTaxCalculate } from './tools';
import type { TariffLookupResult, TaxCalculateResult, ToolError, ToolResult } from '../../types/tools';

const MAX_RETRIES = 3;

interface ExecutionContext {
  retryCount: number;
  errors: ToolError[];
}

interface ToolExecutionResult {
  success: boolean;
  result?: ToolResult;
  error?: ToolError;
  shouldRetry: boolean;
  retryCount: number;
  userMessage?: string;
}

/**
 * ToolExecutor handles validation, execution, and retry logic for AI tools
 */
export class ToolExecutor {
  private executionContexts: Map<string, ExecutionContext> = new Map();

  /**
   * Execute a tool call with Zod validation
   * Returns structured result with retry guidance for AI
   */
  async execute(
    toolName: string,
    args: unknown,
    sessionId: string = 'default'
  ): Promise<ToolExecutionResult> {
    const contextKey = `${sessionId}:${toolName}`;
    let context = this.executionContexts.get(contextKey);

    if (!context) {
      context = { retryCount: 0, errors: [] };
      this.executionContexts.set(contextKey, context);
    }

    // Check retry limit
    if (context.retryCount >= MAX_RETRIES) {
      return {
        success: false,
        shouldRetry: false,
        retryCount: context.retryCount,
        userMessage: 'Ich konnte das nicht berechnen. Bitte überprüfe deine Eingaben und versuche es erneut.',
        error: {
          field: 'max_retries',
          error: `Maximale Versuche (${MAX_RETRIES}) erreicht`,
          suggestion: 'Starte einen neuen Berechnungsversuch',
        },
      };
    }

    // Validate and execute based on tool name
    let result: ToolResult;
    let validationError: ToolError | undefined;

    switch (toolName) {
      case TOOL_NAMES.TARIFF_LOOKUP: {
        const parsed = tariffLookupSchema.safeParse(args);
        if (!parsed.success) {
          validationError = this.zodErrorToToolError(parsed.error);
          context.retryCount++;
          context.errors.push(validationError);
          return {
            success: false,
            error: validationError,
            shouldRetry: context.retryCount < MAX_RETRIES,
            retryCount: context.retryCount,
          };
        }
        result = executeTariffLookup(parsed.data);
        break;
      }

      case TOOL_NAMES.TAX_CALCULATE: {
        const parsed = taxCalculateSchema.safeParse(args);
        if (!parsed.success) {
          validationError = this.zodErrorToToolError(parsed.error);
          context.retryCount++;
          context.errors.push(validationError);
          return {
            success: false,
            error: validationError,
            shouldRetry: context.retryCount < MAX_RETRIES,
            retryCount: context.retryCount,
          };
        }
        result = executeTaxCalculate(parsed.data);
        break;
      }

      default:
        return {
          success: false,
          error: {
            field: 'toolName',
            error: `Unbekanntes Werkzeug: ${toolName}`,
            suggestion: `Verwende ${TOOL_NAMES.TARIFF_LOOKUP} oder ${TOOL_NAMES.TAX_CALCULATE}`,
          },
          shouldRetry: false,
          retryCount: context.retryCount,
        };
    }

    // Check tool execution result
    if (!result.success && result.error) {
      context.retryCount++;
      context.errors.push(result.error);
      return {
        success: false,
        result,
        error: result.error,
        shouldRetry: context.retryCount < MAX_RETRIES,
        retryCount: context.retryCount,
      };
    }

    // Success - reset context for this tool
    this.executionContexts.delete(contextKey);

    return {
      success: true,
      result,
      shouldRetry: false,
      retryCount: context.retryCount,
    };
  }

  /**
   * Convert Zod validation error to ToolError format
   */
  private zodErrorToToolError(error: import('zod').ZodError): ToolError {
    const firstIssue = error.issues[0];
    const field = firstIssue.path.join('.');

    return {
      field: field || 'unknown',
      error: firstIssue.message,
      received: (firstIssue as any).received,
      suggestion: this.getSuggestionForField(field, firstIssue.code),
    };
  }

  /**
   * Generate helpful suggestions based on field and error type
   */
  private getSuggestionForField(field: string, code: string): string {
    const suggestions: Record<string, string> = {
      tarif: 'Verwende tvoed, tv-l, oder avr',
      group: 'Verwende P5-P15 für Pflege oder E5-E15 für allgemein',
      stufe: 'Stufe muss zwischen 1 und 6 liegen',
      taxClass: 'Steuerklasse muss zwischen 1 und 6 liegen',
      year: 'Jahr muss 2025 oder 2026 sein',
      churchTax: 'Verwende none, church_tax_8, oder church_tax_9',
      state: 'Verwende west, east, oder sachsen',
      hours: 'Stunden pro Woche (z.B. 38.5 für Vollzeit)',
      yearlySalary: 'Jahresgehalt in Euro (positiver Wert)',
    };

    return suggestions[field] || `Überprüfe den Wert für ${field}`;
  }

  /**
   * Reset retry context for a session (e.g., when starting new calculation)
   */
  resetContext(sessionId: string = 'default'): void {
    for (const key of this.executionContexts.keys()) {
      if (key.startsWith(sessionId)) {
        this.executionContexts.delete(key);
      }
    }
  }

  /**
   * Build error context message for AI retry
   * Includes previous errors to help AI correct its approach
   */
  buildErrorContextForAI(sessionId: string, toolName: string): string {
    const context = this.executionContexts.get(`${sessionId}:${toolName}`);
    if (!context || context.errors.length === 0) {
      return '';
    }

    const errorLines = context.errors.map((e, i) =>
      `Versuch ${i + 1}: Feld "${e.field}" - ${e.error}${e.suggestion ? ` (${e.suggestion})` : ''}`
    );

    return `\n\nVorherige Fehler bei ${toolName}:\n${errorLines.join('\n')}`;
  }
}

// Singleton instance for shared state across requests
export const toolExecutor = new ToolExecutor();
```

Key features:
- Zod validation before tool execution
- Max 3 retries with error tracking
- Structured ToolError objects for AI retry context
- German suggestions for common fields
- Session-based retry tracking
- buildErrorContextForAI() for injecting error history into prompts

  </action>
  <verify>
TypeScript compilation:
```bash
cd apps/api && npx tsc --noEmit
```

Test executor:
```bash
cd apps/api && npx ts-node -e "
import { toolExecutor } from './utils/agent/ToolExecutor';

// Test successful execution
const result1 = await toolExecutor.execute('tariff_lookup', { tarif: 'tvoed', group: 'P7', stufe: '3' });
console.log('Success case:', result1);

// Test validation failure
const result2 = await toolExecutor.execute('tariff_lookup', { tarif: 'invalid', group: 'P7', stufe: '3' });
console.log('Validation error:', result2);
"
```
  </verify>
  <done>
- ToolExecutor validates inputs with Zod before execution
- Tracks retry count per session/tool
- Returns structured errors with shouldRetry flag
- After 3 retries, returns graceful German user message
- buildErrorContextForAI provides error history for AI retry attempts
  </done>
</task>

<task type="auto">
  <name>Task 3: Update config.ts and GeminiAgent with new tool infrastructure</name>
  <files>apps/api/utils/agent/config.ts, apps/api/utils/agent/GeminiAgent.ts</files>
  <action>
Update config.ts to use Zod-generated tool declarations and update GeminiAgent to use ToolExecutor:

**1. Update `apps/api/utils/agent/config.ts`**

Replace the manual SALARY_TOOL with Zod-generated tools:

```typescript
import { zodToGeminiTool, mergeTools } from './schemaConverter';
import { tariffLookupSchema, taxCalculateSchema, TOOL_NAMES } from './toolSchemas';

// Generate Gemini tool declarations from Zod schemas
const TARIFF_TOOL = zodToGeminiTool(
  TOOL_NAMES.TARIFF_LOOKUP,
  'Schlägt das monatliche Bruttogehalt basierend auf Tarifvertrag (TVöD, TV-L, AVR), Entgeltgruppe und Erfahrungsstufe nach. Muss VOR der Steuerberechnung aufgerufen werden.',
  tariffLookupSchema
);

const TAX_TOOL = zodToGeminiTool(
  TOOL_NAMES.TAX_CALCULATE,
  'Berechnet das Nettogehalt aus dem Jahresbrutto. Benötigt Steuerklasse, Jahr, und optional Kirchensteuer/Kinder. Rufe zuerst tariff_lookup auf um das Brutto zu ermitteln.',
  taxCalculateSchema
);

// Merged tools for Gemini API
export const SALARY_TOOLS = mergeTools(TARIFF_TOOL, TAX_TOOL);

// Keep legacy SALARY_TOOL export for backwards compatibility during migration
export const SALARY_TOOL = SALARY_TOOLS;

export const SYSTEM_INSTRUCTION = `
Du bist ein freundlicher, geduldiger und hilfsbereiter Assistent für den TVöD Pflege Gehaltsrechner.

**WERKZEUG-NUTZUNG (WICHTIG):**
1. Nutze ZUERST 'tariff_lookup' um das Bruttogehalt zu ermitteln
2. Zeige dem Nutzer das Bruttogehalt und erkläre kurz: "Jetzt berechnen wir dein Nettogehalt"
3. Sammle dann die Steuerdaten (Steuerklasse, Kirchensteuer, Kinder)
4. Nutze DANN 'tax_calculate' mit dem Jahresbrutto für die Netto-Berechnung

**GESPRÄCHSSTIL:**
- Du führst ein **ganz normales Gespräch**. Frage nicht nach Tabellenwerten wie "Entgeltgruppe P7" oder "Stufe 3".
- Frage stattdessen nach **Ausbildung, Tätigkeit und Berufserfahrung**.
- **Du** bist der Experte: Du übersetzt die Antworten im Hintergrund in technische Werte.
- Du bist NUR für den Bereich **Pflege** (TVöD-P) zuständig.

**DEIN VORGEHEN:**

1. **Job & Qualifikation:**
   - Frage: "Was hast du gelernt oder als was arbeitest du aktuell?"
   - Mapping:
     - Ungelernte/Helfer ohne Ausbildung -> P5
     - Pflegehelfer (1 Jahr Ausbildung) -> P6
     - Pflegefachkraft (3 Jahre Ausbildung) -> P7/P8
     - Fachweiterbildung (z.B. Intensiv, OP) -> P9
     - Leitungspositionen -> P10-P15

2. **Erfahrung:**
   - Frage: "Wie lange arbeitest du schon in diesem Beruf?"
   - Mapping:
     - Einstieg / < 1 Jahr -> Stufe 1 (bei P7+ oft Stufe 2)
     - 1-3 Jahre -> Stufe 2
     - 3-6 Jahre -> Stufe 3
     - 6-10 Jahre -> Stufe 4
     - 10-15 Jahre -> Stufe 5
     - >15 Jahre -> Stufe 6

3. **Arbeitszeit:**
   - Frage: "Arbeitest du Vollzeit oder Teilzeit? Wie viele Stunden?"

4. **Tarifvertrag (falls unklar):**
   - Frage: "Arbeitest du im öffentlichen Dienst, bei einer kirchlichen Einrichtung, oder woanders?"
   - Mapping: Öffentlich -> tvoed, Kirchlich -> avr, Länder -> tv-l

5. **Nach tariff_lookup - ZEIGE DAS BRUTTO:**
   - "Basierend auf deinen Angaben liegt dein monatliches Bruttogehalt bei etwa X Euro."
   - "Jetzt berechnen wir dein Nettogehalt. Dafür brauche ich noch ein paar Infos zu deiner Steuersituation."

6. **Steuer & Familie:**
   - Statt "Steuerklasse?", frage: "Bist du verheiratet oder ledig?"
   - "Hast du Kinder? Zahlst du Kirchensteuer?"

**FEHLERBEHANDLUNG:**
- Wenn ein Werkzeug fehlschlägt, nutze die Fehlermeldung um deine Parameter zu korrigieren
- Versuche maximal 3x, dann entschuldige dich höflich beim Nutzer

**PROTOKOLL & AUSGABE:**
Halte den Nutzer mit '[PROGRESS: 0-100]' auf dem Laufenden.

Heute ist der {DATUM}.
`;
```

**2. Update `apps/api/utils/agent/GeminiAgent.ts`**

Replace the hardcoded tool execution with ToolExecutor:

```typescript
import { GoogleGenAI, Content } from "@google/genai";
import { SALARY_TOOLS, SYSTEM_INSTRUCTION } from "./config";
import { AgentMessage } from "./types";
import { getGeminiClient } from "../../lib/gemini";
import { toolExecutor } from "./ToolExecutor";
import { TOOL_NAMES } from "./toolSchemas";
import type { TariffLookupResult, TaxCalculateResult } from "../../types/tools";

export class GeminiAgent {
    private client: GoogleGenAI;
    private sessionId: string;

    constructor(sessionId?: string) {
        this.client = getGeminiClient();
        this.sessionId = sessionId || `session-${Date.now()}`;
    }

    async sendMessage(
        message: string,
        history: AgentMessage[],
        contextDocuments?: Content[]
    ): Promise<string> {

        // Prepare System Instruction with current date
        const currentDate = new Date().toLocaleDateString('de-DE', { year: 'numeric', month: 'long', day: 'numeric' });
        const dynamicSystemInstruction = SYSTEM_INSTRUCTION.replace('{DATUM}', currentDate);

        // Map History
        const chatHistory: Content[] = history.map((msg) => {
            const role = msg.role === 'bot' ? 'model' : 'user';

            let parts: { text: string }[] = [];
            if (msg.parts && Array.isArray(msg.parts)) {
                parts = msg.parts.map((p: any) => ({ text: p.text || p }));
            } else if ((msg as any).text) {
                parts = [{ text: (msg as any).text }];
            } else if ((msg as any).content) {
                parts = [{ text: (msg as any).content }];
            }

            return { role, parts };
        });

        // Document Context Injection (RAG)
        if (contextDocuments && contextDocuments.length > 0) {
            chatHistory.unshift(...contextDocuments);
        }

        const chat = this.client.chats.create({
            model: "gemini-2.5-flash",
            config: {
                systemInstruction: dynamicSystemInstruction,
                temperature: 0.7,
                tools: [SALARY_TOOLS],
            },
            history: chatHistory
        });

        let result = await chat.sendMessage({
            message: message
        });

        // ---------------------------------------------------------
        // Tool Execution Loop with Retry Support
        // ---------------------------------------------------------
        let iterations = 0;
        const maxIterations = 6; // Allow multiple tool calls (tariff then tax)

        while (iterations < maxIterations) {
            iterations++;

            // Extract function calls
            let functionCalls = (result as any).functionCalls ? (result as any).functionCalls() : null;

            if (!functionCalls) {
                const parts = (result as any).response?.candidates?.[0]?.content?.parts || [];
                const calls = parts.filter((p: any) => p.functionCall);
                if (calls.length > 0) {
                    functionCalls = calls.map((p: any) => p.functionCall);
                }
            }

            if (!functionCalls || functionCalls.length === 0) {
                break; // No more tool calls, we have our final response
            }

            const call = functionCalls[0];
            console.log(`[GeminiAgent] Executing Tool: ${call.name}`, call.args);

            // Execute tool with validation and retry tracking
            const executionResult = await toolExecutor.execute(
                call.name,
                call.args,
                this.sessionId
            );

            // Build response to send back to model
            let toolResponse: any;

            if (executionResult.success && executionResult.result) {
                // Success - return full result
                toolResponse = { result: executionResult.result };
                console.log(`[GeminiAgent] Tool ${call.name} succeeded:`, executionResult.result);
            } else {
                // Error - return structured error for retry
                const errorContext = toolExecutor.buildErrorContextForAI(this.sessionId, call.name);

                toolResponse = {
                    error: executionResult.error,
                    shouldRetry: executionResult.shouldRetry,
                    retryCount: executionResult.retryCount,
                    context: errorContext,
                };

                // If max retries reached, include user-facing message
                if (executionResult.userMessage) {
                    toolResponse.userMessage = executionResult.userMessage;
                }

                console.log(`[GeminiAgent] Tool ${call.name} failed (attempt ${executionResult.retryCount}):`, executionResult.error);
            }

            // Send tool result back to model
            result = await chat.sendMessage({
                message: [
                    {
                        role: "function",
                        parts: [{
                            functionResponse: {
                                name: call.name,
                                response: toolResponse
                            }
                        }]
                    }
                ]
            } as any);
        }

        // Extract final text response
        const text = (result as any).text || (result as any).response?.text?.() || "";
        return text;
    }

    /**
     * Reset tool execution context (for new conversations)
     */
    resetToolContext(): void {
        toolExecutor.resetContext(this.sessionId);
    }
}
```

Key changes:
- Uses SALARY_TOOLS (Zod-generated) instead of manual SALARY_TOOL
- ToolExecutor handles validation and retry logic
- Loop supports multiple sequential tool calls (tariff -> tax)
- Error responses include context for AI retry
- Session-based tracking for retry counts
- Max 6 iterations allows tariff lookup + tax calculation with potential retries

  </action>
  <verify>
TypeScript compilation:
```bash
cd apps/api && npx tsc --noEmit
```

Verify tools are correctly generated:
```bash
cd apps/api && npx ts-node -e "
import { SALARY_TOOLS } from './utils/agent/config';
console.log(JSON.stringify(SALARY_TOOLS, null, 2));
"
```

Should show two function declarations with German descriptions.
  </verify>
  <done>
- config.ts exports SALARY_TOOLS generated from Zod schemas
- SYSTEM_INSTRUCTION updated with two-step tool workflow
- GeminiAgent uses ToolExecutor for validated execution
- Loop handles sequential tool calls (tariff then tax)
- Error responses enable AI self-correction
- Legacy SALARY_TOOL export maintained for backwards compatibility
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. TypeScript compiles without errors:
```bash
cd apps/api && npx tsc --noEmit
```

2. Tool files exist:
```bash
ls -la apps/api/utils/agent/tools/ apps/api/utils/agent/ToolExecutor.ts
```

3. Run integration test:
```bash
cd apps/api && npx ts-node -e "
import { toolExecutor } from './utils/agent/ToolExecutor';
import { TOOL_NAMES } from './utils/agent/toolSchemas';

async function test() {
  // Test tariff lookup
  const tariff = await toolExecutor.execute(TOOL_NAMES.TARIFF_LOOKUP, { tarif: 'tvoed', group: 'P7', stufe: '3' });
  console.log('Tariff lookup:', tariff);

  if (tariff.success && tariff.result && 'grossSalary' in tariff.result) {
    // Test tax calculation with result
    const tax = await toolExecutor.execute(TOOL_NAMES.TAX_CALCULATE, {
      yearlySalary: tariff.result.grossSalary,
      taxClass: 1,
      year: 2025,
    });
    console.log('Tax calculation:', tax);
  }
}

test();
"
```

4. Generated tools have German descriptions:
```bash
cd apps/api && npx ts-node -e "
import { SALARY_TOOLS } from './utils/agent/config';
const tariff = SALARY_TOOLS.functionDeclarations.find(f => f.name === 'tariff_lookup');
console.log('Tariff tool parameters:', JSON.stringify(tariff?.parameters, null, 2));
"
```
</verification>

<success_criteria>
- tariff_lookup tool returns gross salary for TVöD P7 Stufe 3 (~3447 EUR/month)
- tax_calculate tool returns net salary with breakdown
- Invalid tool parameters trigger Zod validation errors
- Errors include field, message, and suggestion in German
- After 3 failed retries, user sees graceful error message
- GeminiAgent handles sequential tariff -> tax tool calls
- SYSTEM_INSTRUCTION guides AI through two-step workflow
</success_criteria>

<output>
After completion, create `.planning/phases/08-function-calling-enhancement/08-02-SUMMARY.md`
</output>
