---
phase: 08-function-calling-enhancement
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/api/types/tools.ts
  - apps/api/utils/agent/toolSchemas.ts
  - apps/api/utils/agent/schemaConverter.ts
autonomous: true

must_haves:
  truths:
    - "Zod schemas define valid parameter shapes for tariff_lookup and tax_calculate tools"
    - "Gemini function declarations are auto-generated from Zod schemas (no manual JSON)"
    - "Schema field descriptions use German language for AI context"
    - "taxClass uses literal union 1|2|3|4|5|6 (not generic number)"
    - "tarif uses literal union 'tvoed'|'tv-l'|'avr' (not generic string)"
  artifacts:
    - path: "apps/api/types/tools.ts"
      provides: "TypeScript types inferred from Zod schemas for type safety"
      exports: ["TariffLookupInput", "TaxCalculateInput"]
    - path: "apps/api/utils/agent/toolSchemas.ts"
      provides: "Zod schemas as single source of truth for tool validation"
      exports: ["tariffLookupSchema", "taxCalculateSchema"]
    - path: "apps/api/utils/agent/schemaConverter.ts"
      provides: "Function to convert Zod schemas to Gemini tool format"
      exports: ["zodToGeminiTool"]
  key_links:
    - from: "apps/api/utils/agent/toolSchemas.ts"
      to: "apps/api/types/tools.ts"
      via: "z.infer type inference"
      pattern: "z\\.infer<typeof"
    - from: "apps/api/utils/agent/schemaConverter.ts"
      to: "Gemini FunctionDeclaration format"
      via: "zodToGeminiTool function"
      pattern: "functionDeclarations"
---

<objective>
Create Zod-based tool schemas that serve as single source of truth for both TypeScript types AND Gemini function calling definitions.

Purpose: Eliminate schema drift between validation logic and AI tool definitions. When we change a field, both the TypeScript type and Gemini tool description update together.

Output:
- `toolSchemas.ts` with Zod schemas for tariff_lookup and tax_calculate
- `schemaConverter.ts` with utility to convert Zod to Gemini format
- `tools.ts` with TypeScript types inferred from schemas
</objective>

<execution_context>
@/Users/cweissteiner/.claude/get-shit-done/workflows/execute-plan.md
@/Users/cweissteiner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-function-calling-enhancement/08-CONTEXT.md
@apps/api/utils/agent/config.ts
@apps/api/utils/tax/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Zod tool schemas with German descriptions</name>
  <files>apps/api/types/tools.ts, apps/api/utils/agent/toolSchemas.ts</files>
  <action>
Create two new files:

**1. `apps/api/utils/agent/toolSchemas.ts`**

Define Zod schemas for both tools:

```typescript
import { z } from 'zod';

// Tariff Lookup Tool Schema
export const tariffLookupSchema = z.object({
  tarif: z.enum(['tvoed', 'tv-l', 'avr']).describe('Tarifvertrag: TVöD (öffentlicher Dienst), TV-L (Länder), oder AVR (kirchlich)'),
  group: z.string().describe('Entgeltgruppe (z.B. P5, P6, P7, P8, P9 für Pflege oder E5-E15 für allgemein)'),
  stufe: z.enum(['1', '2', '3', '4', '5', '6']).describe('Erfahrungsstufe 1-6 basierend auf Berufsjahren'),
  hours: z.number().min(1).max(48).optional().describe('Wöchentliche Arbeitszeit in Stunden (Standard: 38.5 für Vollzeit)'),
  state: z.string().optional().describe('Bundesland für regionale Tarifunterschiede'),
});

// Tax Calculation Tool Schema
export const taxCalculateSchema = z.object({
  yearlySalary: z.number().positive().describe('Jahresbrutto in Euro'),
  taxClass: z.union([
    z.literal(1),
    z.literal(2),
    z.literal(3),
    z.literal(4),
    z.literal(5),
    z.literal(6),
  ]).describe('Steuerklasse: 1 (ledig), 2 (alleinerziehend), 3 (verheiratet, höheres Einkommen), 4 (verheiratet, gleich), 5 (verheiratet, geringer), 6 (Zweitjob)'),
  year: z.union([z.literal(2025), z.literal(2026)]).describe('Steuerjahr für die Berechnung'),
  churchTax: z.enum(['none', 'church_tax_8', 'church_tax_9']).default('none').describe('Kirchensteuer: keine, 8% (Bayern/BW), oder 9% (übrige Länder)'),
  hasChildren: z.boolean().default(false).describe('Hat der Nutzer Kinder? Relevant für Kinderfreibetrag'),
  childCount: z.number().int().min(0).max(10).default(0).describe('Anzahl der Kinder für Kinderfreibeträge'),
  state: z.enum(['west', 'east', 'sachsen']).default('west').describe('Region: West, Ost, oder Sachsen (für Pflegeversicherung)'),
  birthYear: z.number().int().min(1940).max(2010).optional().describe('Geburtsjahr für Altersentlastungsbetrag'),
  healthInsuranceAddOn: z.number().min(0).max(5).default(1.6).describe('Zusatzbeitrag Krankenversicherung in Prozent (Standard ca. 1.6%)'),
});

// Tool names as constants
export const TOOL_NAMES = {
  TARIFF_LOOKUP: 'tariff_lookup',
  TAX_CALCULATE: 'tax_calculate',
} as const;
```

**2. `apps/api/types/tools.ts`**

Create inferred types from schemas:

```typescript
import { z } from 'zod';
import { tariffLookupSchema, taxCalculateSchema } from '../utils/agent/toolSchemas';

// Inferred types from Zod schemas - single source of truth
export type TariffLookupInput = z.infer<typeof tariffLookupSchema>;
export type TaxCalculateInput = z.infer<typeof taxCalculateSchema>;

// Tool result types
export interface TariffLookupResult {
  success: boolean;
  grossSalary?: number;
  monthlyGross?: number;
  group: string;
  stufe: string;
  tarif: string;
  error?: ToolError;
}

export interface TaxCalculateResult {
  success: boolean;
  netto?: number;
  taxes?: {
    lohnsteuer: number;
    soli: number;
    kirchensteuer: number;
  };
  socialSecurity?: {
    kv: number;
    rv: number;
    av: number;
    pv: number;
  };
  error?: ToolError;
}

// Structured error for AI retry context (from CONTEXT.md decision)
export interface ToolError {
  field: string;
  error: string;
  received?: unknown;
  suggestion?: string;
}

// Union type for all tool results
export type ToolResult = TariffLookupResult | TaxCalculateResult;
```

Key decisions:
- Use `z.enum()` for constrained string values (tarif, churchTax, state)
- Use `z.union()` with `z.literal()` for taxClass (strict 1-6 only)
- German descriptions in `.describe()` help AI understand context
- Optional fields have `.optional()` or `.default()` values
- Inferred types ensure TypeScript catches schema mismatches

  </action>
  <verify>
Run TypeScript compilation:
```bash
cd apps/api && npx tsc --noEmit
```
Should compile without errors.
  </verify>
  <done>
- `toolSchemas.ts` exports tariffLookupSchema and taxCalculateSchema with German descriptions
- `tools.ts` exports TariffLookupInput and TaxCalculateInput types inferred from schemas
- taxClass is literal union 1|2|3|4|5|6, not generic number
- tarif is literal union 'tvoed'|'tv-l'|'avr', not generic string
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Zod-to-Gemini schema converter</name>
  <files>apps/api/utils/agent/schemaConverter.ts</files>
  <action>
Create `apps/api/utils/agent/schemaConverter.ts` that converts Zod schemas to Gemini function calling format:

```typescript
import { z, ZodType, ZodObject, ZodString, ZodNumber, ZodBoolean, ZodEnum, ZodOptional, ZodDefault, ZodLiteral, ZodUnion } from 'zod';

type GeminiPropertyType = 'STRING' | 'NUMBER' | 'BOOLEAN' | 'INTEGER' | 'OBJECT' | 'ARRAY';

interface GeminiProperty {
  type: GeminiPropertyType;
  description?: string;
  enum?: string[];
}

interface GeminiFunctionDeclaration {
  name: string;
  description: string;
  parameters: {
    type: 'OBJECT';
    properties: Record<string, GeminiProperty>;
    required: string[];
  };
}

/**
 * Convert a Zod schema to Gemini function calling format
 *
 * Supports: string, number, boolean, enum, literal unions, optional, default
 * German descriptions from .describe() are preserved
 */
export function zodToGeminiTool(
  name: string,
  description: string,
  schema: ZodObject<any>
): { functionDeclarations: GeminiFunctionDeclaration[] } {
  const shape = schema.shape;
  const properties: Record<string, GeminiProperty> = {};
  const required: string[] = [];

  for (const [key, zodType] of Object.entries(shape)) {
    const { property, isRequired } = convertZodType(key, zodType as ZodType);
    properties[key] = property;
    if (isRequired) {
      required.push(key);
    }
  }

  return {
    functionDeclarations: [{
      name,
      description,
      parameters: {
        type: 'OBJECT',
        properties,
        required,
      },
    }],
  };
}

function convertZodType(key: string, zodType: ZodType): { property: GeminiProperty; isRequired: boolean } {
  let innerType = zodType;
  let isRequired = true;
  let description = (zodType as any)._def?.description;

  // Unwrap ZodOptional
  if (zodType instanceof ZodOptional) {
    innerType = (zodType as any)._def.innerType;
    isRequired = false;
    description = description || (innerType as any)._def?.description;
  }

  // Unwrap ZodDefault
  if (innerType instanceof ZodDefault) {
    innerType = (innerType as any)._def.innerType;
    description = description || (innerType as any)._def?.description;
  }

  const property: GeminiProperty = { type: 'STRING' };
  if (description) {
    property.description = description;
  }

  // Handle ZodEnum
  if (innerType instanceof ZodEnum) {
    property.type = 'STRING';
    property.enum = (innerType as any)._def.values;
    return { property, isRequired };
  }

  // Handle ZodUnion of literals (e.g., taxClass: 1|2|3|4|5|6)
  if (innerType instanceof ZodUnion) {
    const options = (innerType as any)._def.options as ZodType[];
    if (options.every(opt => opt instanceof ZodLiteral)) {
      const values = options.map(opt => (opt as any)._def.value);
      // Check if all literals are numbers
      if (values.every((v: unknown) => typeof v === 'number')) {
        property.type = 'NUMBER';
        property.enum = values.map((v: number) => String(v));
      } else {
        property.type = 'STRING';
        property.enum = values.map(String);
      }
      return { property, isRequired };
    }
  }

  // Handle ZodString
  if (innerType instanceof ZodString) {
    property.type = 'STRING';
    return { property, isRequired };
  }

  // Handle ZodNumber
  if (innerType instanceof ZodNumber) {
    // Check if it's an integer
    const checks = (innerType as any)._def.checks || [];
    const isInt = checks.some((c: any) => c.kind === 'int');
    property.type = isInt ? 'INTEGER' : 'NUMBER';
    return { property, isRequired };
  }

  // Handle ZodBoolean
  if (innerType instanceof ZodBoolean) {
    property.type = 'BOOLEAN';
    return { property, isRequired };
  }

  // Handle ZodLiteral (single value)
  if (innerType instanceof ZodLiteral) {
    const value = (innerType as any)._def.value;
    if (typeof value === 'number') {
      property.type = 'NUMBER';
    } else if (typeof value === 'boolean') {
      property.type = 'BOOLEAN';
    } else {
      property.type = 'STRING';
    }
    return { property, isRequired };
  }

  // Default to STRING
  return { property, isRequired };
}

/**
 * Merge multiple tool declarations into a single tools object
 */
export function mergeTools(
  ...tools: { functionDeclarations: GeminiFunctionDeclaration[] }[]
): { functionDeclarations: GeminiFunctionDeclaration[] } {
  return {
    functionDeclarations: tools.flatMap(t => t.functionDeclarations),
  };
}
```

This converter:
- Preserves German `.describe()` text as Gemini parameter descriptions
- Handles `z.enum()` as string enums
- Handles `z.union([z.literal(1), z.literal(2), ...])` as number enums
- Properly marks optional fields (not in `required` array)
- Handles `z.default()` wrapped types
- Merges multiple tool schemas for multi-tool setup

  </action>
  <verify>
Create a simple test inline or run TypeScript:
```bash
cd apps/api && npx tsc --noEmit
```

Then verify the converter works by adding a temporary test in the file and running:
```bash
cd apps/api && npx ts-node -e "
import { tariffLookupSchema, taxCalculateSchema } from './utils/agent/toolSchemas';
import { zodToGeminiTool, mergeTools } from './utils/agent/schemaConverter';

const tariffTool = zodToGeminiTool('tariff_lookup', 'Schlägt das Bruttogehalt basierend auf Tarifvertrag, Gruppe und Stufe nach', tariffLookupSchema);
const taxTool = zodToGeminiTool('tax_calculate', 'Berechnet das Nettogehalt aus dem Bruttogehalt', taxCalculateSchema);
const merged = mergeTools(tariffTool, taxTool);

console.log(JSON.stringify(merged, null, 2));
"
```

Output should show:
- Two functionDeclarations (tariff_lookup, tax_calculate)
- German descriptions for each parameter
- taxClass with enum ["1", "2", "3", "4", "5", "6"]
- tarif with enum ["tvoed", "tv-l", "avr"]
  </verify>
  <done>
- `schemaConverter.ts` exports zodToGeminiTool and mergeTools functions
- Zod schemas convert to Gemini FunctionDeclaration format
- German descriptions from .describe() appear in Gemini tool definitions
- Enum values correctly mapped (taxClass as number enum, tarif as string enum)
- Optional/default fields correctly marked in required array
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. TypeScript compiles without errors:
```bash
cd apps/api && npx tsc --noEmit
```

2. Schema files exist with correct exports:
```bash
ls -la apps/api/utils/agent/toolSchemas.ts apps/api/utils/agent/schemaConverter.ts apps/api/types/tools.ts
```

3. Generated Gemini tool definitions contain German descriptions and correct enum values
</verification>

<success_criteria>
- Zod schemas define tariff_lookup and tax_calculate parameter shapes
- TypeScript types inferred from schemas (not manually defined)
- zodToGeminiTool converts schemas to Gemini format with German descriptions
- taxClass uses literal union 1|2|3|4|5|6 (strict)
- tarif uses literal union 'tvoed'|'tv-l'|'avr' (strict)
- Validation errors are catchable via Zod's safeParse
</success_criteria>

<output>
After completion, create `.planning/phases/08-function-calling-enhancement/08-01-SUMMARY.md`
</output>
