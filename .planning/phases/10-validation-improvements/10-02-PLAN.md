---
phase: 10-validation-improvements
plan: 02
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - apps/api/app/api/chat/route.ts
  - apps/api/lib/suggestions.ts
autonomous: true

must_haves:
  truths:
    - "Extracted field values are validated with Zod before being accepted into formState"
    - "Validation errors display as friendly German messages in chat response"
    - "After 3 failed validation attempts, suggestion chips appear with valid options"
    - "AI re-prompts user with specific correction request referencing the validation error"
  artifacts:
    - path: "apps/api/app/api/chat/route.ts"
      provides: "Chat route with integrated two-phase validation"
      contains: "fieldValidator.validate"
    - path: "apps/api/lib/suggestions.ts"
      provides: "Escalation chip generation for validation failures"
      exports: ["generateEscalationChips"]
  key_links:
    - from: "apps/api/app/api/chat/route.ts"
      to: "apps/api/utils/agent/FieldValidator.ts"
      via: "import and validate call"
      pattern: "fieldValidator\\.validate"
    - from: "apps/api/app/api/chat/route.ts"
      to: "apps/api/lib/suggestions.ts"
      via: "escalation chips on 3rd failure"
      pattern: "generateEscalationChips"
---

<objective>
Integrate FieldValidator into the chat flow to implement two-phase validation (LLM extracts -> Zod validates) with German re-prompting and escalation chips.

Purpose: Ensure data extraction is reliable with user-friendly German error messages that guide users to correct their input. After 3 failures, provide chips to help users select valid options.

Output:
- Updated chat/route.ts with FieldValidator integration
- Updated suggestions.ts with escalation chip generation
</objective>

<execution_context>
@/Users/cweissteiner/.claude/get-shit-done/workflows/execute-plan.md
@/Users/cweissteiner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-validation-improvements/10-CONTEXT.md
@.planning/phases/10-validation-improvements/10-01-SUMMARY.md
@apps/api/app/api/chat/route.ts
@apps/api/lib/suggestions.ts
@apps/api/utils/agent/FieldValidator.ts
@apps/api/utils/agent/formFieldSchemas.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add escalation chip generation to suggestions.ts</name>
  <files>apps/api/lib/suggestions.ts</files>
  <action>
Add a function to generate escalation chips when validation fails 3 times.

**Add function:**
```typescript
/**
 * Generate escalation chips when validation fails repeatedly
 * Called after 3 validation attempts to help user select valid option
 */
export function generateEscalationChips(
  field: string,
  validOptions: string[]
): string[] {
  // Return user-friendly chip labels
  // Map internal values to German display labels
  const fieldLabels: Record<string, Record<string, string>> = {
    tarif: {
      'tvoed': 'TVöD (öffentlicher Dienst)',
      'tv-l': 'TV-L (Länder)',
      'avr': 'AVR (kirchlich)',
    },
    taxClass: {
      '1': 'Klasse 1 (ledig)',
      '2': 'Klasse 2 (alleinerziehend)',
      '3': 'Klasse 3 (verheiratet, höher)',
      '4': 'Klasse 4 (verheiratet, gleich)',
      '5': 'Klasse 5 (verheiratet, niedriger)',
      '6': 'Klasse 6 (Zweitjob)',
    },
    churchTax: {
      'true': 'Ja, Kirchenmitglied',
      'false': 'Nein, keine Kirchensteuer',
    },
    numberOfChildren: {
      '0': 'Keine Kinder',
      '1': '1 Kind',
      '2': '2 Kinder',
      '3': '3+ Kinder',
    },
    // For other fields, use valid options directly
  };

  const labels = fieldLabels[field];
  if (labels) {
    return validOptions.map(opt => labels[opt] || opt).slice(0, 4);
  }

  // Return raw options for fields without custom labels (max 4)
  return validOptions.slice(0, 4);
}
```

**Update generateSuggestions to accept escalation override:**
Modify the function signature to accept optional escalation chips that override normal suggestion logic.

```typescript
export async function generateSuggestions(
  formState: FormState,
  responseText: string,
  escalationChips?: string[]  // NEW: Override with validation escalation chips
): Promise<string[]> {
  // If escalation chips provided, return them immediately
  if (escalationChips && escalationChips.length > 0) {
    return escalationChips;
  }

  // ... existing logic unchanged ...
}
```
  </action>
  <verify>
TypeScript compiles: `cd apps/api && npx tsc --noEmit`
Function exported: `grep "generateEscalationChips" apps/api/lib/suggestions.ts`
  </verify>
  <done>
generateEscalationChips function added with German labels, generateSuggestions updated to accept escalation override.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate FieldValidator into chat route extraction flow</name>
  <files>apps/api/app/api/chat/route.ts</files>
  <action>
Replace the current ResponseValidator usage with FieldValidator for two-phase validation.

**Import FieldValidator:**
```typescript
import { fieldValidator, type FieldValidationResult } from '../../../utils/agent/FieldValidator';
import { generateEscalationChips } from '../../../lib/suggestions';
```

**Modify the extraction section (around line 524-590):**

Replace the current validation loop with FieldValidator integration:

```typescript
// --- US-005 & US-006: EXTRACTION PHASE WITH TWO-PHASE VALIDATION ---
if ((nextFormState.userIntent === 'data' || nextFormState.userIntent === 'modification') &&
    nextFormState.missingFields && nextFormState.missingFields.length > 0) {

    // ... existing extraction prompt logic unchanged ...

    try {
        const result = await client.models.generateContent({
            model: 'gemini-2.5-flash',
            contents: extractPrompt,
            config: { responseMimeType: 'application/json' }
        });
        const text = result.text || '';
        const cleanJson = text.replace(/```json/g, '').replace(/```/g, '').trim();
        const extraction = JSON.parse(cleanJson);

        if (extraction.extracted && Object.keys(extraction.extracted).length > 0) {
            const section = nextFormState.section as 'job_details' | 'tax_details';
            if (!nextFormState.data[section]) nextFormState.data[section] = {};

            // Session ID for retry tracking - use activeProjectId only (persists across requests)
            // DO NOT include Date.now() as it would reset retry count each request
            const validationSessionId = activeProjectId;

            for (const [field, value] of Object.entries(extraction.extracted)) {
                // TWO-PHASE VALIDATION: LLM extracted -> Zod validates
                const validationResult: FieldValidationResult = fieldValidator.validate(
                    field,
                    value,
                    validationSessionId,
                    nextFormState  // Pass formState for cross-field validation (e.g., group needs tarif)
                );

                if (validationResult.valid) {
                    // Accept normalized value
                    nextFormState.data[section]![field] = validationResult.normalizedValue ?? value;
                    // Clear any previous error for this field
                    if (nextFormState.validationErrors?.[field]) {
                        delete nextFormState.validationErrors[field];
                    }
                } else {
                    // Store validation error
                    if (!nextFormState.validationErrors) nextFormState.validationErrors = {};
                    nextFormState.validationErrors[field] = validationResult.error?.message || 'Ungültiger Wert';

                    // Check if escalation needed (3 failures)
                    if (validationResult.shouldEscalate && validationResult.error?.validOptions) {
                        // Generate escalation chips
                        const escalationChips = generateEscalationChips(
                            field,
                            validationResult.error.validOptions
                        );

                        // Build escalation response
                        const escalationPrompt = `
Du bist ein freundlicher Gehalts-Chatbot.
Der Nutzer hat Schwierigkeiten mit der Eingabe für "${SalaryStateMachine.getFieldLabel(field)}".

Bisherige Versuche: ${validationResult.retryCount}
Letzter Wert: "${validationResult.error?.received || value}"

Aufgabe: Hilf dem Nutzer freundlich. Erkläre kurz, dass du die Eingabe nicht verstanden hast.
Zeige Verständnis und biete an, aus den Optionen zu wählen.

Beispiel-Antwort:
"Kein Problem, das kann verwirrend sein! Für die ${SalaryStateMachine.getFieldLabel(field)} kannst du einfach eine der Optionen unten antippen."

Halte dich kurz (1-2 Sätze).
                        `;

                        const escalationResponse = await client.models.generateContent({
                            model: 'gemini-2.5-flash',
                            contents: escalationPrompt
                        });

                        const escalationText = (escalationResponse.text || '') +
                            `\n\n[PROGRESS: ${SalaryStateMachine.getProgress(nextFormState)}]`;

                        return NextResponse.json({
                            text: escalationText,
                            formState: nextFormState,
                            suggestions: escalationChips
                        });
                    }
                }
            }
        }
    } catch (e) {
        console.error("[StateMachine] Extraction failed:", e);
    }
}
```

**Update the validation error handling section (around line 593-621):**

Modify to generate better re-prompts with the structured error information:

```typescript
// --- US-008: GENERATE RE-PROMPT IF VALIDATION ERRORS ---
if (nextFormState.validationErrors && Object.keys(nextFormState.validationErrors).length > 0) {
    const errorEntries = Object.entries(nextFormState.validationErrors);
    const firstError = errorEntries[0];
    const [errorField, errorMessage] = firstError;

    // Build re-prompt with specific correction request
    const rePromptContent = `
Du bist ein freundlicher Gehalts-Chatbot für Pflegekräfte.

Bei der Angabe für "${SalaryStateMachine.getFieldLabel(errorField)}" gab es ein Problem:
${errorMessage}

Aufgabe: Erkläre dem Nutzer freundlich, was nicht geklappt hat.
- Zeige Verständnis
- Gib 2-3 Beispiele für gültige Eingaben
- Frage direkt nach dem korrekten Wert

Beispiel-Formulierung:
"Hmm, das habe ich nicht ganz verstanden. ${errorMessage} Kannst du mir das nochmal sagen? Zum Beispiel: ..."

WICHTIG:
- Sei freundlich und geduldig
- Sprich den Nutzer direkt an (du)
- Halte dich kurz (2-3 Sätze)
    `;

    const rePromptResult = await client.models.generateContent({
        model: 'gemini-2.5-flash',
        contents: rePromptContent
    });

    const rePromptText = (rePromptResult.text || '') +
        `\n\n[PROGRESS: ${SalaryStateMachine.getProgress(nextFormState)}]`;

    return NextResponse.json({
        text: rePromptText,
        formState: nextFormState,
        suggestions: await generateSuggestions(nextFormState, rePromptText)
    });
}
```

**Update modification handler (summary phase modification detection):**

Location: Search for `if (modification.field && modification.newValue && modification.section)` pattern (around line 459 based on grep results). This is inside the summary phase handling block where user modifications are processed.

Verify `activeProjectId` is in scope: It's declared at line 36 (`let activeProjectId = projectId || apiKey`) and is available throughout the route handler.

Add FieldValidator to the modification flow:

```typescript
// Inside the modification handling block (replace the existing responseValidator.validate call)
if (modification.field && modification.newValue && modification.section) {
    // Use FieldValidator instead of ResponseValidator
    // activeProjectId is declared at line 36, available here
    const validationResult = fieldValidator.validate(
        modification.field,
        modification.newValue,
        activeProjectId,  // Use activeProjectId for session tracking (no :mod suffix, keeps retry counts)
        nextFormState     // Pass formState for cross-field validation
    );

    if (validationResult.valid) {
        // Update the field with normalized value
        const section = modification.section as 'job_details' | 'tax_details';
        if (!nextFormState.data[section]) {
            nextFormState.data[section] = {};
        }
        nextFormState.data[section]![modification.field] = validationResult.normalizedValue ?? modification.newValue;

        // ... rest of success handling unchanged ...
    } else {
        // Handle validation failure
        nextFormState.validationErrors = {
            [modification.field]: validationResult.error?.message || 'Ungültiger Wert'
        };

        // Check escalation
        if (validationResult.shouldEscalate && validationResult.error?.validOptions) {
            const escalationChips = generateEscalationChips(
                modification.field,
                validationResult.error.validOptions
            );
            // ... escalation response ...
        }
    }
}
```

**Remove unused ResponseValidator import if no longer needed elsewhere.**
  </action>
  <verify>
TypeScript compiles: `cd apps/api && npx tsc --noEmit`
FieldValidator imported: `grep "fieldValidator" apps/api/app/api/chat/route.ts`
generateEscalationChips imported: `grep "generateEscalationChips" apps/api/app/api/chat/route.ts`
  </verify>
  <done>
Chat route uses FieldValidator for two-phase validation with German error re-prompts and escalation chips after 3 failures.
  </done>
</task>

</tasks>

<verification>
After both tasks:
1. TypeScript compiles: `cd apps/api && npx tsc --noEmit` passes
2. FieldValidator integrated: `grep -c "fieldValidator.validate" apps/api/app/api/chat/route.ts` returns at least 2
3. Escalation chips work: `grep "generateEscalationChips" apps/api/app/api/chat/route.ts` finds import and usage
4. No regressions: API still handles chat requests correctly
</verification>

<success_criteria>
- Extracted values validated with Zod schema before acceptance
- Validation errors display friendly German messages
- After 3 failures, suggestion chips appear with valid options
- AI re-prompts reference the specific validation error
- Modification flow also uses two-phase validation
</success_criteria>

<output>
After completion, create `.planning/phases/10-validation-improvements/10-02-SUMMARY.md`
</output>
