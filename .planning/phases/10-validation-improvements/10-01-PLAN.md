---
phase: 10-validation-improvements
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/api/utils/agent/formFieldSchemas.ts
  - apps/api/utils/agent/FieldValidator.ts
autonomous: true

must_haves:
  truths:
    - "Zod schemas exist for all form fields (tarif, group, experience, hours, state, taxClass, churchTax, numberOfChildren)"
    - "German number words (eins, zwei, drei...) are converted to numbers before validation"
    - "Validation errors include casual/friendly German messages with valid options"
    - "Near-miss invalid values suggest closest valid option"
    - "Group field validation uses tarif from formState to determine P vs E prefix"
  artifacts:
    - path: "apps/api/utils/agent/formFieldSchemas.ts"
      provides: "Zod schemas for form fields with German error messages"
      exports: ["tarifSchema", "groupSchema", "experienceSchema", "hoursSchema", "stateSchema", "taxClassSchema", "churchTaxSchema", "numberOfChildrenSchema", "GERMAN_NUMBER_WORDS"]
    - path: "apps/api/utils/agent/FieldValidator.ts"
      provides: "Field validation service with retry tracking and German error formatting"
      exports: ["FieldValidator", "ValidationContext", "FieldValidationResult"]
  key_links:
    - from: "apps/api/utils/agent/FieldValidator.ts"
      to: "apps/api/utils/agent/formFieldSchemas.ts"
      via: "import schemas"
      pattern: "import.*formFieldSchemas"
    - from: "apps/api/utils/agent/FieldValidator.ts"
      to: "apps/api/types/form.ts"
      via: "import FormState for cross-field validation"
      pattern: "import.*FormState.*from.*form"
---

<objective>
Create Zod schemas for form field validation with German pre-processors (number words) and friendly error messages.

Purpose: Enable two-phase validation (LLM extraction -> Zod validation) with user-friendly German feedback that feels conversational, not technical.

Output:
- formFieldSchemas.ts: Zod schemas for each form field with German .describe() and custom error messages
- FieldValidator.ts: Validation service with retry tracking, German error formatting, and near-miss suggestions
</objective>

<execution_context>
@/Users/cweissteiner/.claude/get-shit-done/workflows/execute-plan.md
@/Users/cweissteiner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-validation-improvements/10-CONTEXT.md
@apps/api/utils/agent/toolSchemas.ts
@apps/api/utils/agent/ResponseValidator.ts
@apps/api/types/form.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Zod form field schemas with German pre-processors</name>
  <files>apps/api/utils/agent/formFieldSchemas.ts</files>
  <action>
Create Zod schemas for all form fields collected during the salary interview.

**Field schemas to create:**

1. **tarifSchema**: enum ['tvoed', 'tv-l', 'avr'] with pre-processor
   - Accept variations: 'TVöD', 'TVÖD', 'tvöd', 'oeffentlicher dienst' -> 'tvoed'
   - Accept: 'TV-L', 'tvl', 'laender' -> 'tv-l'
   - Accept: 'AVR', 'kirchlich', 'diakonie', 'caritas' -> 'avr'
   - German error: "Hmm, '{input}' kenne ich nicht als Tarifvertrag. Arbeitest du im öffentlichen Dienst (TVöD), bei den Ländern (TV-L), oder kirchlich (AVR)?"

2. **groupSchema**: string matching pattern P5-P15 or E5-E15
   - Accept with/without prefix: '7', 'P7', 'E7', 'p7', 'e7'
   - Accept spelled out: 'sieben' -> '7' (then needs tarif context for P/E)
   - German error: "Die Entgeltgruppe '{input}' kenne ich nicht. Pflege ist meist P5-P15, andere Bereiche E5-E15."
   - NOTE: This schema validates the format only (number 5-15, optional P/E prefix). Cross-field validation (determining P vs E based on tarif) is handled in FieldValidator.validate() which receives formState context. See Task 2.

3. **experienceSchema**: string or number 1-6 (Stufe) or years
   - Accept: '1', '2', 'Stufe 3', '5 Jahre', 'fuenf Jahre'
   - Pre-process German number words: 'eins' -> 1, 'zwei' -> 2, etc.
   - German error: "Die Erfahrungsstufe '{input}' verstehe ich nicht. Wie lange bist du schon dabei? (z.B. '3 Jahre' oder 'Stufe 2')"

4. **hoursSchema**: number 1-48
   - Accept: 38.5, '38,5', 'Vollzeit' -> 38.5, 'Teilzeit' -> 20
   - German error: "Hmm, {input} Stunden pro Woche? Das klingt ungewöhnlich. Vollzeit ist meist 38-40 Stunden."

5. **stateSchema**: German Bundesland string
   - Accept abbreviations: 'NRW', 'BW', 'BY' and full names
   - German error: "'{input}' kenne ich nicht als Bundesland. Meinst du vielleicht {suggestion}?"

6. **taxClassSchema**: literal union 1|2|3|4|5|6
   - Accept: '1', 1, 'Klasse 1', 'eins', 'ledig' -> 1
   - Accept: 'verheiratet' -> ask follow-up (4 or 3/5)
   - German error: "Steuerklasse '{input}' gibt es nicht — bitte wähle 1-6. Zum Beispiel: 1 (ledig), 3 (verheiratet, höheres Einkommen), oder 4 (verheiratet, gleich)."

7. **churchTaxSchema**: boolean
   - Accept: 'ja', 'nein', 'yes', 'no', true, false, 'evangelisch', 'katholisch' -> true, 'konfessionslos', 'ausgetreten' -> false
   - German error: "Bei der Kirchensteuer verstehe ich '{input}' nicht. Bist du Mitglied in einer Kirche? (ja/nein)"

8. **numberOfChildrenSchema**: integer 0-10
   - Accept: 0, '0', 'keine', 'null', 'nein', 'no' -> 0
   - Accept: German number words: 'eins', 'zwei', 'drei' -> 1, 2, 3
   - German error: "Die Kinderanzahl '{input}' verstehe ich nicht. Wie viele Kinder hast du? (z.B. '2' oder 'keine')"

**Create GERMAN_NUMBER_WORDS map:**
```typescript
const GERMAN_NUMBER_WORDS: Record<string, number> = {
  'null': 0, 'keine': 0, 'kein': 0, 'nein': 0,
  'eins': 1, 'ein': 1, 'eine': 1,
  'zwei': 2, 'zwo': 2,
  'drei': 3,
  'vier': 4,
  'fuenf': 5, 'fünf': 5,
  'sechs': 6,
  'sieben': 7,
  'acht': 8,
  'neun': 9,
  'zehn': 10,
};
```

**Use Zod preprocess for transformations:**
```typescript
const taxClassSchema = z.preprocess(
  (val) => {
    // Transform German words and strings to numbers
    const str = String(val).toLowerCase().trim();
    if (str in GERMAN_NUMBER_WORDS) return GERMAN_NUMBER_WORDS[str];
    const match = str.match(/(\d)/);
    if (match) return parseInt(match[1], 10);
    return val;
  },
  z.union([z.literal(1), z.literal(2), z.literal(3), z.literal(4), z.literal(5), z.literal(6)])
).describe('Steuerklasse 1-6');
```

**Export all schemas and helper maps.**
  </action>
  <verify>
TypeScript compiles: `cd apps/api && npx tsc --noEmit`
Schemas are exported: `grep -E "export (const|function)" apps/api/utils/agent/formFieldSchemas.ts`
  </verify>
  <done>
8 Zod schemas exported with German error messages and pre-processors for number words and common variations.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create FieldValidator service with retry tracking</name>
  <files>apps/api/utils/agent/FieldValidator.ts</files>
  <action>
Create a FieldValidator service that wraps Zod validation with retry tracking, German error formatting, and near-miss suggestions.

**Interface:**
```typescript
export interface FieldValidationResult {
  valid: boolean;
  normalizedValue?: unknown;
  error?: {
    message: string;           // User-friendly German message
    field: string;             // Field name
    received: string;          // What user provided
    suggestion?: string;       // Near-miss suggestion if applicable
    validOptions?: string[];   // List of valid options for chips
  };
  retryCount: number;
  shouldEscalate: boolean;     // True after 3 failures -> show chips
}

export interface ValidationContext {
  retryCount: number;
  lastErrors: string[];
}
```

**Class structure:**
```typescript
export class FieldValidator {
  private contexts: Map<string, ValidationContext> = new Map();
  private readonly MAX_RETRIES = 3;

  /**
   * Validate a field value using Zod schema
   * @param field Field name (tarif, taxClass, etc.)
   * @param value Raw value from extraction
   * @param sessionId For retry tracking - use activeProjectId (persists across requests)
   * @param formState Optional - required for cross-field validation (e.g., group needs tarif)
   */
  validate(field: string, value: unknown, sessionId: string, formState?: FormState): FieldValidationResult

  /**
   * Reset validation context (e.g., when starting new conversation)
   */
  resetContext(sessionId: string): void

  /**
   * Get valid options for a field (for escalation chips)
   */
  getValidOptions(field: string): string[]

  /**
   * Format a friendly German error message
   */
  private formatGermanError(field: string, zodError: ZodError, received: unknown): string

  /**
   * Find near-miss suggestion (e.g., 7 -> 6)
   */
  private findNearMiss(field: string, value: unknown): string | undefined
}
```

**Validation flow:**
1. Get or create context for `{sessionId}:{field}` (sessionId should be activeProjectId which persists across requests in a session)
2. Check if already at max retries -> return escalation result with chips
3. Parse value with Zod schema from formFieldSchemas.ts
4. For group field: if formState provided and tarif is set, apply P/E prefix logic:
   - If tarif is TVöD/AVR with Pflege context -> use P prefix (P5-P15)
   - Otherwise -> use E prefix (E5-E15)
   - If just number provided without prefix, add appropriate prefix based on tarif
5. On success: reset context, return normalized value
6. On failure: increment retry count, format German error, check for near-miss

**Cross-field validation (group depends on tarif):**
When validating group field:
- If formState.data.job_details.tarif exists, use it to determine P vs E prefix
- If user provides bare number (e.g., "7"), infer prefix from tarif context
- Store both the normalized value ("P7" or "E7") based on context

**Near-miss logic:**
- For numeric fields (taxClass, numberOfChildren): if value is close (e.g., 7 for taxClass), suggest 6
- For enum fields (tarif): use Levenshtein distance to suggest closest match
- For boolean fields (churchTax): suggest based on partial matches

**German error formatting:**
- Use template from schema error or build custom message
- Always include what user entered: "Du hast '{received}' eingegeben..."
- Always include valid options: "Gültige Werte sind: ..."
- For near-misses: "Meintest du vielleicht '{suggestion}'?"

**Escalation behavior (after 3 retries):**
- Set `shouldEscalate: true`
- Include `validOptions` array for chip generation
- Message: "Kein Problem, das ist manchmal verwirrend. Hier sind die Optionen:"

**Export singleton instance:**
```typescript
export const fieldValidator = new FieldValidator();
```
  </action>
  <verify>
TypeScript compiles: `cd apps/api && npx tsc --noEmit`
Exports check: `grep -E "export (class|const|interface)" apps/api/utils/agent/FieldValidator.ts`
  </verify>
  <done>
FieldValidator class exported with validate(), resetContext(), getValidOptions() methods and friendly German error formatting with retry tracking.
  </done>
</task>

</tasks>

<verification>
After both tasks:
1. TypeScript compiles: `cd apps/api && npx tsc --noEmit` passes
2. formFieldSchemas.ts exports all 8 schemas plus GERMAN_NUMBER_WORDS
3. FieldValidator.ts exports class, interfaces, and singleton
4. No regressions: existing tests pass (if any)
</verification>

<success_criteria>
- Zod schemas for all form fields with German error messages
- German number words pre-processed (eins -> 1)
- Retry tracking with 3-attempt escalation
- Near-miss suggestions for close invalid values
- Friendly German error formatting (conversational tone)
</success_criteria>

<output>
After completion, create `.planning/phases/10-validation-improvements/10-01-SUMMARY.md`
</output>
